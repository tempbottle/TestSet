/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.70, Date: 07-Oct-2004.
 */
#include "..\ooasn1.h"
#include "H323-MESSAGES.h"

/**************************************************************/
/*                                                            */
/*  ProtocolIdentifier                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225ProtocolIdentifier (OOCTXT* pctxt, H225ProtocolIdentifier* pvalue)
{
   int stat = ASN_OK;

   stat = decodeObjectIdentifier (pctxt, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportAddress_ipAddress_ip                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225TransportAddress_ipAddress_ip (OOCTXT* pctxt, H225TransportAddress_ipAddress_ip* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 4, 4, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportAddress_ipAddress                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225TransportAddress_ipAddress (OOCTXT* pctxt, H225TransportAddress_ipAddress* pvalue)
{
   int stat = ASN_OK;

   /* decode ip */

   stat = asn1PD_H225TransportAddress_ipAddress_ip (pctxt, &pvalue->ip);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode port */

   stat = decodeConsUInt16 (pctxt, &pvalue->port, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportAddress_ipSourceRoute_ip                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225TransportAddress_ipSourceRoute_ip (OOCTXT* pctxt, H225TransportAddress_ipSourceRoute_ip* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 4, 4, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportAddress_ipSourceRoute_route_element              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225TransportAddress_ipSourceRoute_route_element (OOCTXT* pctxt, H225TransportAddress_ipSourceRoute_route_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 4, 4, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH225TransportAddress_ipSourceRoute_route_element    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225_SeqOfH225TransportAddress_ipSourceRoute_route_element (OOCTXT* pctxt, H225_SeqOfH225TransportAddress_ipSourceRoute_route_element* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, H225TransportAddress_ipSourceRoute_route_element);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_H225TransportAddress_ipSourceRoute_route_element (pctxt, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportAddress_ipSourceRoute_routing                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225TransportAddress_ipSourceRoute_routing (OOCTXT* pctxt, H225TransportAddress_ipSourceRoute_routing* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* strict */
         case 0:
            /* NULL */

            break;

         /* loose */
         case 1:
            /* NULL */

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportAddress_ipSourceRoute                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225TransportAddress_ipSourceRoute (OOCTXT* pctxt, H225TransportAddress_ipSourceRoute* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode ip */

   stat = asn1PD_H225TransportAddress_ipSourceRoute_ip (pctxt, &pvalue->ip);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode port */

   stat = decodeConsUInt16 (pctxt, &pvalue->port, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode route */

   stat = asn1PD_H225_SeqOfH225TransportAddress_ipSourceRoute_route_element (pctxt, &pvalue->route);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode routing */

   stat = asn1PD_H225TransportAddress_ipSourceRoute_routing (pctxt, &pvalue->routing);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportAddress_ipxAddress_node                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225TransportAddress_ipxAddress_node (OOCTXT* pctxt, H225TransportAddress_ipxAddress_node* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 6, 6, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportAddress_ipxAddress_netnum                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225TransportAddress_ipxAddress_netnum (OOCTXT* pctxt, H225TransportAddress_ipxAddress_netnum* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 4, 4, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportAddress_ipxAddress_port                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225TransportAddress_ipxAddress_port (OOCTXT* pctxt, H225TransportAddress_ipxAddress_port* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 2, 2, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportAddress_ipxAddress                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225TransportAddress_ipxAddress (OOCTXT* pctxt, H225TransportAddress_ipxAddress* pvalue)
{
   int stat = ASN_OK;

   /* decode node */

   stat = asn1PD_H225TransportAddress_ipxAddress_node (pctxt, &pvalue->node);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode netnum */

   stat = asn1PD_H225TransportAddress_ipxAddress_netnum (pctxt, &pvalue->netnum);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode port */

   stat = asn1PD_H225TransportAddress_ipxAddress_port (pctxt, &pvalue->port);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportAddress_ip6Address_ip                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225TransportAddress_ip6Address_ip (OOCTXT* pctxt, H225TransportAddress_ip6Address_ip* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 16, 16, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportAddress_ip6Address                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225TransportAddress_ip6Address (OOCTXT* pctxt, H225TransportAddress_ip6Address* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode ip */

   stat = asn1PD_H225TransportAddress_ip6Address_ip (pctxt, &pvalue->ip);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode port */

   stat = decodeConsUInt16 (pctxt, &pvalue->port, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportAddress_netBios                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225TransportAddress_netBios (OOCTXT* pctxt, H225TransportAddress_netBios* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 16, 16, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportAddress_nsap                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225TransportAddress_nsap (OOCTXT* pctxt, H225TransportAddress_nsap* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 20, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H221NonStandard                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225H221NonStandard (OOCTXT* pctxt, H225H221NonStandard* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode t35CountryCode */

   stat = decodeConsUInt8 (pctxt, &pvalue->t35CountryCode, 0U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode t35Extension */

   stat = decodeConsUInt8 (pctxt, &pvalue->t35Extension, 0U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode manufacturerCode */

   stat = decodeConsUInt16 (pctxt, &pvalue->manufacturerCode, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NonStandardIdentifier                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225NonStandardIdentifier (OOCTXT* pctxt, H225NonStandardIdentifier* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* object */
         case 0:
            pvalue->u.object = ALLOC_ASN1ELEM (pctxt, ASN1OBJID);
            if (pvalue->u.object == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = decodeObjectIdentifier (pctxt, pvalue->u.object);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* h221NonStandard */
         case 1:
            pvalue->u.h221NonStandard = ALLOC_ASN1ELEM (pctxt, H225H221NonStandard);
            if (pvalue->u.h221NonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225H221NonStandard (pctxt, pvalue->u.h221NonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NonStandardParameter                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225NonStandardParameter (OOCTXT* pctxt, H225NonStandardParameter* pvalue)
{
   int stat = ASN_OK;

   /* decode nonStandardIdentifier */

   stat = asn1PD_H225NonStandardIdentifier (pctxt, &pvalue->nonStandardIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode data */

   stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->data);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransportAddress                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225TransportAddress (OOCTXT* pctxt, H225TransportAddress* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 6);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* ipAddress */
         case 0:
            pvalue->u.ipAddress = ALLOC_ASN1ELEM (pctxt, H225TransportAddress_ipAddress);
            if (pvalue->u.ipAddress == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225TransportAddress_ipAddress (pctxt, pvalue->u.ipAddress);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* ipSourceRoute */
         case 1:
            pvalue->u.ipSourceRoute = ALLOC_ASN1ELEM (pctxt, H225TransportAddress_ipSourceRoute);
            if (pvalue->u.ipSourceRoute == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225TransportAddress_ipSourceRoute (pctxt, pvalue->u.ipSourceRoute);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* ipxAddress */
         case 2:
            pvalue->u.ipxAddress = ALLOC_ASN1ELEM (pctxt, H225TransportAddress_ipxAddress);
            if (pvalue->u.ipxAddress == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225TransportAddress_ipxAddress (pctxt, pvalue->u.ipxAddress);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* ip6Address */
         case 3:
            pvalue->u.ip6Address = ALLOC_ASN1ELEM (pctxt, H225TransportAddress_ip6Address);
            if (pvalue->u.ip6Address == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225TransportAddress_ip6Address (pctxt, pvalue->u.ip6Address);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* netBios */
         case 4:
            pvalue->u.netBios = ALLOC_ASN1ELEM (pctxt, H225TransportAddress_netBios);
            if (pvalue->u.netBios == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225TransportAddress_netBios (pctxt, pvalue->u.netBios);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* nsap */
         case 5:
            pvalue->u.nsap = ALLOC_ASN1ELEM (pctxt, H225TransportAddress_nsap);
            if (pvalue->u.nsap == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225TransportAddress_nsap (pctxt, pvalue->u.nsap);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* nonStandardAddress */
         case 6:
            pvalue->u.nonStandardAddress = ALLOC_ASN1ELEM (pctxt, H225NonStandardParameter);
            if (pvalue->u.nonStandardAddress == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225NonStandardParameter (pctxt, pvalue->u.nonStandardAddress);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 8;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PublicTypeOfNumber                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225PublicTypeOfNumber (OOCTXT* pctxt, H225PublicTypeOfNumber* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 5);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unknown */
         case 0:
            /* NULL */

            break;

         /* internationalNumber */
         case 1:
            /* NULL */

            break;

         /* nationalNumber */
         case 2:
            /* NULL */

            break;

         /* networkSpecificNumber */
         case 3:
            /* NULL */

            break;

         /* subscriberNumber */
         case 4:
            /* NULL */

            break;

         /* abbreviatedNumber */
         case 5:
            /* NULL */

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 7;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NumberDigits                                              */
/*                                                            */
/**************************************************************/

extern EXTERN const char* gs_H323_MESSAGES_NumberDigits_CharSet;

EXTERN int asn1PD_H225NumberDigits (OOCTXT* pctxt, H225NumberDigits* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 128, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeConstrainedStringEx (pctxt, pvalue, gs_H323_MESSAGES_NumberDigits_CharSet, 4, 4, 7);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PublicPartyNumber                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225PublicPartyNumber (OOCTXT* pctxt, H225PublicPartyNumber* pvalue)
{
   int stat = ASN_OK;

   /* decode publicTypeOfNumber */

   stat = asn1PD_H225PublicTypeOfNumber (pctxt, &pvalue->publicTypeOfNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode publicNumberDigits */

   stat = asn1PD_H225NumberDigits (pctxt, &pvalue->publicNumberDigits);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrivateTypeOfNumber                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225PrivateTypeOfNumber (OOCTXT* pctxt, H225PrivateTypeOfNumber* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 5);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unknown */
         case 0:
            /* NULL */

            break;

         /* level2RegionalNumber */
         case 1:
            /* NULL */

            break;

         /* level1RegionalNumber */
         case 2:
            /* NULL */

            break;

         /* pISNSpecificNumber */
         case 3:
            /* NULL */

            break;

         /* localNumber */
         case 4:
            /* NULL */

            break;

         /* abbreviatedNumber */
         case 5:
            /* NULL */

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 7;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PrivatePartyNumber                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225PrivatePartyNumber (OOCTXT* pctxt, H225PrivatePartyNumber* pvalue)
{
   int stat = ASN_OK;

   /* decode privateTypeOfNumber */

   stat = asn1PD_H225PrivateTypeOfNumber (pctxt, &pvalue->privateTypeOfNumber);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode privateNumberDigits */

   stat = asn1PD_H225NumberDigits (pctxt, &pvalue->privateNumberDigits);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PartyNumber                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225PartyNumber (OOCTXT* pctxt, H225PartyNumber* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 4);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* e164Number */
         case 0:
            pvalue->u.e164Number = ALLOC_ASN1ELEM (pctxt, H225PublicPartyNumber);
            if (pvalue->u.e164Number == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225PublicPartyNumber (pctxt, pvalue->u.e164Number);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* dataPartyNumber */
         case 1:
            stat = asn1PD_H225NumberDigits (pctxt, &pvalue->u.dataPartyNumber);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* telexPartyNumber */
         case 2:
            stat = asn1PD_H225NumberDigits (pctxt, &pvalue->u.telexPartyNumber);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* privateNumber */
         case 3:
            pvalue->u.privateNumber = ALLOC_ASN1ELEM (pctxt, H225PrivatePartyNumber);
            if (pvalue->u.privateNumber == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225PrivatePartyNumber (pctxt, pvalue->u.privateNumber);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* nationalStandardPartyNumber */
         case 4:
            stat = asn1PD_H225NumberDigits (pctxt, &pvalue->u.nationalStandardPartyNumber);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 6;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TBCD_STRING                                               */
/*                                                            */
/**************************************************************/

extern EXTERN const char* gs_H323_MESSAGES_TBCD_STRING_CharSet;

EXTERN int asn1PD_H225TBCD_STRING (OOCTXT* pctxt, H225TBCD_STRING* pvalue)
{
   int stat = ASN_OK;

   stat = decodeConstrainedStringEx (pctxt, pvalue, gs_H323_MESSAGES_TBCD_STRING_CharSet, 4, 4, 7);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ANSI_41_UIM_system_id                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225ANSI_41_UIM_system_id (OOCTXT* pctxt, H225ANSI_41_UIM_system_id* pvalue)
{
   static Asn1SizeCnst sid_lsize1 = { 0, 1, 4, 0 };
   static Asn1SizeCnst mid_lsize1 = { 0, 1, 4, 0 };
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* sid */
         case 0:
            stat = addSizeConstraint (pctxt, &sid_lsize1);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1PD_H225TBCD_STRING (pctxt, &pvalue->u.sid);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* mid */
         case 1:
            stat = addSizeConstraint (pctxt, &mid_lsize1);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            stat = asn1PD_H225TBCD_STRING (pctxt, &pvalue->u.mid);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ANSI_41_UIM_systemMyTypeCode                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225ANSI_41_UIM_systemMyTypeCode (OOCTXT* pctxt, H225ANSI_41_UIM_systemMyTypeCode* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 1, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ANSI_41_UIM_systemAccessType                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225ANSI_41_UIM_systemAccessType (OOCTXT* pctxt, H225ANSI_41_UIM_systemAccessType* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 1, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ANSI_41_UIM_qualificationInformationCode                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225ANSI_41_UIM_qualificationInformationCode (OOCTXT* pctxt, H225ANSI_41_UIM_qualificationInformationCode* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 1, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ANSI_41_UIM                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225ANSI_41_UIM (OOCTXT* pctxt, H225ANSI_41_UIM* pvalue)
{
   static Asn1SizeCnst imsi_lsize1 = { 0, 3, 16, 0 };
   static Asn1SizeCnst min_lsize1 = { 0, 3, 16, 0 };
   static Asn1SizeCnst mdn_lsize1 = { 0, 3, 16, 0 };
   static Asn1SizeCnst msisdn_lsize1 = { 0, 3, 16, 0 };
   static Asn1SizeCnst esn_lsize1 = { 0, 16, 16, 0 };
   static Asn1SizeCnst mscid_lsize1 = { 0, 3, 16, 0 };
   static Asn1SizeCnst sesn_lsize1 = { 0, 16, 16, 0 };
   static Asn1SizeCnst soc_lsize1 = { 0, 3, 16, 0 };
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.imsiPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.minPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mdnPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.msisdnPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.esnPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mscidPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.systemMyTypeCodePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.systemAccessTypePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.qualificationInformationCodePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sesnPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.socPresent = optbit;

   /* decode imsi */

   if (pvalue->m.imsiPresent) {
      stat = addSizeConstraint (pctxt, &imsi_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = asn1PD_H225TBCD_STRING (pctxt, &pvalue->imsi);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode min */

   if (pvalue->m.minPresent) {
      stat = addSizeConstraint (pctxt, &min_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = asn1PD_H225TBCD_STRING (pctxt, &pvalue->min);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode mdn */

   if (pvalue->m.mdnPresent) {
      stat = addSizeConstraint (pctxt, &mdn_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = asn1PD_H225TBCD_STRING (pctxt, &pvalue->mdn);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode msisdn */

   if (pvalue->m.msisdnPresent) {
      stat = addSizeConstraint (pctxt, &msisdn_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = asn1PD_H225TBCD_STRING (pctxt, &pvalue->msisdn);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode esn */

   if (pvalue->m.esnPresent) {
      stat = addSizeConstraint (pctxt, &esn_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = asn1PD_H225TBCD_STRING (pctxt, &pvalue->esn);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode mscid */

   if (pvalue->m.mscidPresent) {
      stat = addSizeConstraint (pctxt, &mscid_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = asn1PD_H225TBCD_STRING (pctxt, &pvalue->mscid);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode system_id */

   stat = asn1PD_H225ANSI_41_UIM_system_id (pctxt, &pvalue->system_id);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode systemMyTypeCode */

   if (pvalue->m.systemMyTypeCodePresent) {
      stat = asn1PD_H225ANSI_41_UIM_systemMyTypeCode (pctxt, &pvalue->systemMyTypeCode);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode systemAccessType */

   if (pvalue->m.systemAccessTypePresent) {
      stat = asn1PD_H225ANSI_41_UIM_systemAccessType (pctxt, &pvalue->systemAccessType);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode qualificationInformationCode */

   if (pvalue->m.qualificationInformationCodePresent) {
      stat = asn1PD_H225ANSI_41_UIM_qualificationInformationCode (pctxt, &pvalue->qualificationInformationCode);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode sesn */

   if (pvalue->m.sesnPresent) {
      stat = addSizeConstraint (pctxt, &sesn_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = asn1PD_H225TBCD_STRING (pctxt, &pvalue->sesn);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode soc */

   if (pvalue->m.socPresent) {
      stat = addSizeConstraint (pctxt, &soc_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = asn1PD_H225TBCD_STRING (pctxt, &pvalue->soc);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GSM_UIM_tmsi                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225GSM_UIM_tmsi (OOCTXT* pctxt, H225GSM_UIM_tmsi* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 4, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GSM_UIM                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225GSM_UIM (OOCTXT* pctxt, H225GSM_UIM* pvalue)
{
   static Asn1SizeCnst imsi_lsize1 = { 0, 3, 16, 0 };
   static Asn1SizeCnst msisdn_lsize1 = { 0, 3, 16, 0 };
   static Asn1SizeCnst imei_lsize1 = { 0, 15, 16, 0 };
   static Asn1SizeCnst hplmn_lsize1 = { 0, 1, 4, 0 };
   static Asn1SizeCnst vplmn_lsize1 = { 0, 1, 4, 0 };
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.imsiPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tmsiPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.msisdnPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.imeiPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.hplmnPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.vplmnPresent = optbit;

   /* decode imsi */

   if (pvalue->m.imsiPresent) {
      stat = addSizeConstraint (pctxt, &imsi_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = asn1PD_H225TBCD_STRING (pctxt, &pvalue->imsi);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode tmsi */

   if (pvalue->m.tmsiPresent) {
      stat = asn1PD_H225GSM_UIM_tmsi (pctxt, &pvalue->tmsi);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode msisdn */

   if (pvalue->m.msisdnPresent) {
      stat = addSizeConstraint (pctxt, &msisdn_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = asn1PD_H225TBCD_STRING (pctxt, &pvalue->msisdn);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode imei */

   if (pvalue->m.imeiPresent) {
      stat = addSizeConstraint (pctxt, &imei_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = asn1PD_H225TBCD_STRING (pctxt, &pvalue->imei);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode hplmn */

   if (pvalue->m.hplmnPresent) {
      stat = addSizeConstraint (pctxt, &hplmn_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = asn1PD_H225TBCD_STRING (pctxt, &pvalue->hplmn);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode vplmn */

   if (pvalue->m.vplmnPresent) {
      stat = addSizeConstraint (pctxt, &vplmn_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = asn1PD_H225TBCD_STRING (pctxt, &pvalue->vplmn);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MobileUIM                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225MobileUIM (OOCTXT* pctxt, H225MobileUIM* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* ansi_41_uim */
         case 0:
            pvalue->u.ansi_41_uim = ALLOC_ASN1ELEM (pctxt, H225ANSI_41_UIM);
            if (pvalue->u.ansi_41_uim == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225ANSI_41_UIM (pctxt, pvalue->u.ansi_41_uim);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* gsm_uim */
         case 1:
            pvalue->u.gsm_uim = ALLOC_ASN1ELEM (pctxt, H225GSM_UIM);
            if (pvalue->u.gsm_uim == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225GSM_UIM (pctxt, pvalue->u.gsm_uim);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AliasAddress                                              */
/*                                                            */
/**************************************************************/

extern EXTERN const char* gs_H323_MESSAGES_AliasAddress_dialedDigits_CharSet;

EXTERN int asn1PD_H225AliasAddress (OOCTXT* pctxt, H225AliasAddress* pvalue)
{
   static Asn1SizeCnst dialedDigits_lsize1 = { 0, 1, 128, 0 };
   static Asn1SizeCnst h323_ID_lsize1 = { 0, 1, 256, 0 };
   static Asn1SizeCnst url_ID_lsize1 = { 0, 1, 512, 0 };
   static Asn1SizeCnst email_ID_lsize1 = { 0, 1, 512, 0 };
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* dialedDigits */
         case 0:
            stat = addSizeConstraint (pctxt, &dialedDigits_lsize1);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            stat = decodeConstrainedStringEx (pctxt, &pvalue->u.dialedDigits, gs_H323_MESSAGES_AliasAddress_dialedDigits_CharSet, 4, 4, 7);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* h323_ID */
         case 1:
            stat = addSizeConstraint (pctxt, &h323_ID_lsize1);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            stat = decodeBMPString (pctxt, &pvalue->u.h323_ID, 0);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* url_ID */
         case 3:
            stat = addSizeConstraint (pctxt, &url_ID_lsize1);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            stat = decodeConstrainedStringEx (pctxt, &pvalue->u.url_ID, 0, 8, 7, 7);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* transportID */
         case 4:
            pvalue->u.transportID = ALLOC_ASN1ELEM (pctxt, H225TransportAddress);
            if (pvalue->u.transportID == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225TransportAddress (pctxt, pvalue->u.transportID);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* email_ID */
         case 5:
            stat = addSizeConstraint (pctxt, &email_ID_lsize1);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            stat = decodeConstrainedStringEx (pctxt, &pvalue->u.email_ID, 0, 8, 7, 7);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* partyNumber */
         case 6:
            pvalue->u.partyNumber = ALLOC_ASN1ELEM (pctxt, H225PartyNumber);
            if (pvalue->u.partyNumber == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225PartyNumber (pctxt, pvalue->u.partyNumber);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* mobileUIM */
         case 7:
            pvalue->u.mobileUIM = ALLOC_ASN1ELEM (pctxt, H225MobileUIM);
            if (pvalue->u.mobileUIM == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225MobileUIM (pctxt, pvalue->u.mobileUIM);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH225AliasAddress                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225_SeqOfH225AliasAddress (OOCTXT* pctxt, H225_SeqOfH225AliasAddress* pvalue)
{
   int stat = ASN_OK;
   H225AliasAddress* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225AliasAddress);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H225AliasAddress (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VendorIdentifier_productId                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225VendorIdentifier_productId (OOCTXT* pctxt, H225VendorIdentifier_productId* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VendorIdentifier_versionId                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225VendorIdentifier_versionId (OOCTXT* pctxt, H225VendorIdentifier_versionId* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 256, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VendorIdentifier                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225VendorIdentifier (OOCTXT* pctxt, H225VendorIdentifier* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.productIdPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.versionIdPresent = optbit;

   /* decode vendor */

   stat = asn1PD_H225H221NonStandard (pctxt, &pvalue->vendor);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode productId */

   if (pvalue->m.productIdPresent) {
      stat = asn1PD_H225VendorIdentifier_productId (pctxt, &pvalue->productId);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode versionId */

   if (pvalue->m.versionIdPresent) {
      stat = asn1PD_H225VendorIdentifier_versionId (pctxt, &pvalue->versionId);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 1 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.enterpriseNumberPresent = 1;

                     stat = decodeObjectIdentifier (pctxt, &pvalue->enterpriseNumber);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GatekeeperInfo                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225GatekeeperInfo (OOCTXT* pctxt, H225GatekeeperInfo* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BandWidth                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225BandWidth (OOCTXT* pctxt, H225BandWidth* pvalue)
{
   int stat = ASN_OK;

   stat = decodeConsUnsigned (pctxt, pvalue, 0U, ASN1UINT_MAX);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DataRate                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225DataRate (OOCTXT* pctxt, H225DataRate* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.channelMultiplierPresent = optbit;

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode channelRate */

   stat = asn1PD_H225BandWidth (pctxt, &pvalue->channelRate);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode channelMultiplier */

   if (pvalue->m.channelMultiplierPresent) {
      stat = decodeConsUInt16 (pctxt, &pvalue->channelMultiplier, 1U, 256U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH225DataRate                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225_SeqOfH225DataRate (OOCTXT* pctxt, H225_SeqOfH225DataRate* pvalue)
{
   int stat = ASN_OK;
   H225DataRate* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225DataRate);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H225DataRate (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SupportedPrefix                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225SupportedPrefix (OOCTXT* pctxt, H225SupportedPrefix* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode prefix */

   stat = asn1PD_H225AliasAddress (pctxt, &pvalue->prefix);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH225SupportedPrefix                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225_SeqOfH225SupportedPrefix (OOCTXT* pctxt, H225_SeqOfH225SupportedPrefix* pvalue)
{
   int stat = ASN_OK;
   H225SupportedPrefix* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225SupportedPrefix);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H225SupportedPrefix (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H310Caps                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225H310Caps (OOCTXT* pctxt, H225H310Caps* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 2 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.dataRatesSupportedPresent = 1;

                     stat = asn1PD_H225_SeqOfH225DataRate (pctxt, &pvalue->dataRatesSupported);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 1:
                     pvalue->m.supportedPrefixesPresent = 1;

                     stat = asn1PD_H225_SeqOfH225SupportedPrefix (pctxt, &pvalue->supportedPrefixes);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H320Caps                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225H320Caps (OOCTXT* pctxt, H225H320Caps* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 2 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.dataRatesSupportedPresent = 1;

                     stat = asn1PD_H225_SeqOfH225DataRate (pctxt, &pvalue->dataRatesSupported);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 1:
                     pvalue->m.supportedPrefixesPresent = 1;

                     stat = asn1PD_H225_SeqOfH225SupportedPrefix (pctxt, &pvalue->supportedPrefixes);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H321Caps                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225H321Caps (OOCTXT* pctxt, H225H321Caps* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 2 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.dataRatesSupportedPresent = 1;

                     stat = asn1PD_H225_SeqOfH225DataRate (pctxt, &pvalue->dataRatesSupported);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 1:
                     pvalue->m.supportedPrefixesPresent = 1;

                     stat = asn1PD_H225_SeqOfH225SupportedPrefix (pctxt, &pvalue->supportedPrefixes);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H322Caps                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225H322Caps (OOCTXT* pctxt, H225H322Caps* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 2 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.dataRatesSupportedPresent = 1;

                     stat = asn1PD_H225_SeqOfH225DataRate (pctxt, &pvalue->dataRatesSupported);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 1:
                     pvalue->m.supportedPrefixesPresent = 1;

                     stat = asn1PD_H225_SeqOfH225SupportedPrefix (pctxt, &pvalue->supportedPrefixes);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H323Caps                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225H323Caps (OOCTXT* pctxt, H225H323Caps* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 2 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.dataRatesSupportedPresent = 1;

                     stat = asn1PD_H225_SeqOfH225DataRate (pctxt, &pvalue->dataRatesSupported);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 1:
                     pvalue->m.supportedPrefixesPresent = 1;

                     stat = asn1PD_H225_SeqOfH225SupportedPrefix (pctxt, &pvalue->supportedPrefixes);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H324Caps                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225H324Caps (OOCTXT* pctxt, H225H324Caps* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 2 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.dataRatesSupportedPresent = 1;

                     stat = asn1PD_H225_SeqOfH225DataRate (pctxt, &pvalue->dataRatesSupported);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 1:
                     pvalue->m.supportedPrefixesPresent = 1;

                     stat = asn1PD_H225_SeqOfH225SupportedPrefix (pctxt, &pvalue->supportedPrefixes);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VoiceCaps                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225VoiceCaps (OOCTXT* pctxt, H225VoiceCaps* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 2 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.dataRatesSupportedPresent = 1;

                     stat = asn1PD_H225_SeqOfH225DataRate (pctxt, &pvalue->dataRatesSupported);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 1:
                     pvalue->m.supportedPrefixesPresent = 1;

                     stat = asn1PD_H225_SeqOfH225SupportedPrefix (pctxt, &pvalue->supportedPrefixes);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  T120OnlyCaps                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225T120OnlyCaps (OOCTXT* pctxt, H225T120OnlyCaps* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 2 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.dataRatesSupportedPresent = 1;

                     stat = asn1PD_H225_SeqOfH225DataRate (pctxt, &pvalue->dataRatesSupported);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 1:
                     pvalue->m.supportedPrefixesPresent = 1;

                     stat = asn1PD_H225_SeqOfH225SupportedPrefix (pctxt, &pvalue->supportedPrefixes);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NonStandardProtocol                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225NonStandardProtocol (OOCTXT* pctxt, H225NonStandardProtocol* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dataRatesSupportedPresent = optbit;

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode dataRatesSupported */

   if (pvalue->m.dataRatesSupportedPresent) {
      stat = asn1PD_H225_SeqOfH225DataRate (pctxt, &pvalue->dataRatesSupported);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode supportedPrefixes */

   stat = asn1PD_H225_SeqOfH225SupportedPrefix (pctxt, &pvalue->supportedPrefixes);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  T38FaxAnnexbOnlyCaps                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225T38FaxAnnexbOnlyCaps (OOCTXT* pctxt, H225T38FaxAnnexbOnlyCaps* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dataRatesSupportedPresent = optbit;

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode dataRatesSupported */

   if (pvalue->m.dataRatesSupportedPresent) {
      stat = asn1PD_H225_SeqOfH225DataRate (pctxt, &pvalue->dataRatesSupported);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode supportedPrefixes */

   stat = asn1PD_H225_SeqOfH225SupportedPrefix (pctxt, &pvalue->supportedPrefixes);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode t38FaxProtocol */

   stat = asn1PD_H245DataProtocolCapability (pctxt, &pvalue->t38FaxProtocol);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode t38FaxProfile */

   stat = asn1PD_H245T38FaxProfile (pctxt, &pvalue->t38FaxProfile);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SIPCaps                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225SIPCaps (OOCTXT* pctxt, H225SIPCaps* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.dataRatesSupportedPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.supportedPrefixesPresent = optbit;

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode dataRatesSupported */

   if (pvalue->m.dataRatesSupportedPresent) {
      stat = asn1PD_H225_SeqOfH225DataRate (pctxt, &pvalue->dataRatesSupported);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode supportedPrefixes */

   if (pvalue->m.supportedPrefixesPresent) {
      stat = asn1PD_H225_SeqOfH225SupportedPrefix (pctxt, &pvalue->supportedPrefixes);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SupportedProtocols                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225SupportedProtocols (OOCTXT* pctxt, H225SupportedProtocols* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 8);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandardData */
         case 0:
            pvalue->u.nonStandardData = ALLOC_ASN1ELEM (pctxt, H225NonStandardParameter);
            if (pvalue->u.nonStandardData == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225NonStandardParameter (pctxt, pvalue->u.nonStandardData);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* h310 */
         case 1:
            pvalue->u.h310 = ALLOC_ASN1ELEM (pctxt, H225H310Caps);
            if (pvalue->u.h310 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225H310Caps (pctxt, pvalue->u.h310);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* h320 */
         case 2:
            pvalue->u.h320 = ALLOC_ASN1ELEM (pctxt, H225H320Caps);
            if (pvalue->u.h320 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225H320Caps (pctxt, pvalue->u.h320);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* h321 */
         case 3:
            pvalue->u.h321 = ALLOC_ASN1ELEM (pctxt, H225H321Caps);
            if (pvalue->u.h321 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225H321Caps (pctxt, pvalue->u.h321);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* h322 */
         case 4:
            pvalue->u.h322 = ALLOC_ASN1ELEM (pctxt, H225H322Caps);
            if (pvalue->u.h322 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225H322Caps (pctxt, pvalue->u.h322);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* h323 */
         case 5:
            pvalue->u.h323 = ALLOC_ASN1ELEM (pctxt, H225H323Caps);
            if (pvalue->u.h323 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225H323Caps (pctxt, pvalue->u.h323);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* h324 */
         case 6:
            pvalue->u.h324 = ALLOC_ASN1ELEM (pctxt, H225H324Caps);
            if (pvalue->u.h324 == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225H324Caps (pctxt, pvalue->u.h324);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* voice */
         case 7:
            pvalue->u.voice = ALLOC_ASN1ELEM (pctxt, H225VoiceCaps);
            if (pvalue->u.voice == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225VoiceCaps (pctxt, pvalue->u.voice);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* t120_only */
         case 8:
            pvalue->u.t120_only = ALLOC_ASN1ELEM (pctxt, H225T120OnlyCaps);
            if (pvalue->u.t120_only == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225T120OnlyCaps (pctxt, pvalue->u.t120_only);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 10;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* nonStandardProtocol */
         case 10:
            pvalue->u.nonStandardProtocol = ALLOC_ASN1ELEM (pctxt, H225NonStandardProtocol);
            if (pvalue->u.nonStandardProtocol == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225NonStandardProtocol (pctxt, pvalue->u.nonStandardProtocol);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* t38FaxAnnexbOnly */
         case 11:
            pvalue->u.t38FaxAnnexbOnly = ALLOC_ASN1ELEM (pctxt, H225T38FaxAnnexbOnlyCaps);
            if (pvalue->u.t38FaxAnnexbOnly == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225T38FaxAnnexbOnlyCaps (pctxt, pvalue->u.t38FaxAnnexbOnly);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* sip */
         case 12:
            pvalue->u.sip = ALLOC_ASN1ELEM (pctxt, H225SIPCaps);
            if (pvalue->u.sip == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225SIPCaps (pctxt, pvalue->u.sip);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH225SupportedProtocols                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225_SeqOfH225SupportedProtocols (OOCTXT* pctxt, H225_SeqOfH225SupportedProtocols* pvalue)
{
   int stat = ASN_OK;
   H225SupportedProtocols* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225SupportedProtocols);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H225SupportedProtocols (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GatewayInfo                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225GatewayInfo (OOCTXT* pctxt, H225GatewayInfo* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   /* decode protocol */

   if (pvalue->m.protocolPresent) {
      stat = asn1PD_H225_SeqOfH225SupportedProtocols (pctxt, &pvalue->protocol);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  McuInfo                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225McuInfo (OOCTXT* pctxt, H225McuInfo* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 1 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.protocolPresent = 1;

                     stat = asn1PD_H225_SeqOfH225SupportedProtocols (pctxt, &pvalue->protocol);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalInfo                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225TerminalInfo (OOCTXT* pctxt, H225TerminalInfo* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EndpointType_set                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225EndpointType_set (OOCTXT* pctxt, H225EndpointType_set* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 32, 32, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeBitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TunnelledProtocolAlternateIdentifier                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225TunnelledProtocolAlternateIdentifier (OOCTXT* pctxt, H225TunnelledProtocolAlternateIdentifier* pvalue)
{
   static Asn1SizeCnst protocolType_lsize1 = { 0, 1, 64, 0 };
   static Asn1SizeCnst protocolVariant_lsize1 = { 0, 1, 64, 0 };
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.protocolVariantPresent = optbit;

   /* decode protocolType */

   stat = addSizeConstraint (pctxt, &protocolType_lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeConstrainedStringEx (pctxt, &pvalue->protocolType, 0, 8, 7, 7);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocolVariant */

   if (pvalue->m.protocolVariantPresent) {
      stat = addSizeConstraint (pctxt, &protocolVariant_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeConstrainedStringEx (pctxt, &pvalue->protocolVariant, 0, 8, 7, 7);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TunnelledProtocol_id                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225TunnelledProtocol_id (OOCTXT* pctxt, H225TunnelledProtocol_id* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* tunnelledProtocolObjectID */
         case 0:
            pvalue->u.tunnelledProtocolObjectID = ALLOC_ASN1ELEM (pctxt, ASN1OBJID);
            if (pvalue->u.tunnelledProtocolObjectID == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = decodeObjectIdentifier (pctxt, pvalue->u.tunnelledProtocolObjectID);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* tunnelledProtocolAlternateID */
         case 1:
            pvalue->u.tunnelledProtocolAlternateID = ALLOC_ASN1ELEM (pctxt, H225TunnelledProtocolAlternateIdentifier);
            if (pvalue->u.tunnelledProtocolAlternateID == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225TunnelledProtocolAlternateIdentifier (pctxt, pvalue->u.tunnelledProtocolAlternateID);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TunnelledProtocol                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225TunnelledProtocol (OOCTXT* pctxt, H225TunnelledProtocol* pvalue)
{
   static Asn1SizeCnst subIdentifier_lsize1 = { 0, 1, 64, 0 };
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.subIdentifierPresent = optbit;

   /* decode id */

   stat = asn1PD_H225TunnelledProtocol_id (pctxt, &pvalue->id);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode subIdentifier */

   if (pvalue->m.subIdentifierPresent) {
      stat = addSizeConstraint (pctxt, &subIdentifier_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeConstrainedStringEx (pctxt, &pvalue->subIdentifier, 0, 8, 7, 7);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH225TunnelledProtocol                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225_SeqOfH225TunnelledProtocol (OOCTXT* pctxt, H225_SeqOfH225TunnelledProtocol* pvalue)
{
   int stat = ASN_OK;
   H225TunnelledProtocol* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225TunnelledProtocol);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H225TunnelledProtocol (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EndpointType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225EndpointType (OOCTXT* pctxt, H225EndpointType* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.vendorPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.gatekeeperPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.gatewayPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mcuPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.terminalPresent = optbit;

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode vendor */

   if (pvalue->m.vendorPresent) {
      stat = asn1PD_H225VendorIdentifier (pctxt, &pvalue->vendor);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode gatekeeper */

   if (pvalue->m.gatekeeperPresent) {
      stat = asn1PD_H225GatekeeperInfo (pctxt, &pvalue->gatekeeper);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode gateway */

   if (pvalue->m.gatewayPresent) {
      stat = asn1PD_H225GatewayInfo (pctxt, &pvalue->gateway);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode mcu */

   if (pvalue->m.mcuPresent) {
      stat = asn1PD_H225McuInfo (pctxt, &pvalue->mcu);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode terminal */

   if (pvalue->m.terminalPresent) {
      stat = asn1PD_H225TerminalInfo (pctxt, &pvalue->terminal);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode mc */

   stat = DECODEBIT (pctxt, &pvalue->mc);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode undefinedNode */

   stat = DECODEBIT (pctxt, &pvalue->undefinedNode);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 2 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.setPresent = 1;

                     stat = asn1PD_H225EndpointType_set (pctxt, &pvalue->set);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 1:
                     pvalue->m.supportedTunnelledProtocolsPresent = 1;

                     stat = asn1PD_H225_SeqOfH225TunnelledProtocol (pctxt, &pvalue->supportedTunnelledProtocols);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CallReferenceValue                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CallReferenceValue (OOCTXT* pctxt, H225CallReferenceValue* pvalue)
{
   int stat = ASN_OK;

   stat = decodeConsUInt16 (pctxt, pvalue, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH225CallReferenceValue                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225_SeqOfH225CallReferenceValue (OOCTXT* pctxt, H225_SeqOfH225CallReferenceValue* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, H225CallReferenceValue);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_H225CallReferenceValue (pctxt, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GloballyUniqueID                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225GloballyUniqueID (OOCTXT* pctxt, H225GloballyUniqueID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 16, 16, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConferenceIdentifier                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225ConferenceIdentifier (OOCTXT* pctxt, H225ConferenceIdentifier* pvalue)
{
   int stat = ASN_OK;

   stat = asn1PD_H225GloballyUniqueID (pctxt, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Setup_UUIE_conferenceGoal                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Setup_UUIE_conferenceGoal (OOCTXT* pctxt, H225Setup_UUIE_conferenceGoal* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* create */
         case 0:
            /* NULL */

            break;

         /* join */
         case 1:
            /* NULL */

            break;

         /* invite */
         case 2:
            /* NULL */

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* capability_negotiation */
         case 4:
            /* NULL */

            break;

         /* callIndependentSupplementaryService */
         case 5:
            /* NULL */

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Q954Details                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Q954Details (OOCTXT* pctxt, H225Q954Details* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode conferenceCalling */

   stat = DECODEBIT (pctxt, &pvalue->conferenceCalling);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode threePartyService */

   stat = DECODEBIT (pctxt, &pvalue->threePartyService);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QseriesOptions                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225QseriesOptions (OOCTXT* pctxt, H225QseriesOptions* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode q932Full */

   stat = DECODEBIT (pctxt, &pvalue->q932Full);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode q951Full */

   stat = DECODEBIT (pctxt, &pvalue->q951Full);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode q952Full */

   stat = DECODEBIT (pctxt, &pvalue->q952Full);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode q953Full */

   stat = DECODEBIT (pctxt, &pvalue->q953Full);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode q955Full */

   stat = DECODEBIT (pctxt, &pvalue->q955Full);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode q956Full */

   stat = DECODEBIT (pctxt, &pvalue->q956Full);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode q957Full */

   stat = DECODEBIT (pctxt, &pvalue->q957Full);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode q954Info */

   stat = asn1PD_H225Q954Details (pctxt, &pvalue->q954Info);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CallType                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CallType (OOCTXT* pctxt, H225CallType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* pointToPoint */
         case 0:
            /* NULL */

            break;

         /* oneToN */
         case 1:
            /* NULL */

            break;

         /* nToOne */
         case 2:
            /* NULL */

            break;

         /* nToN */
         case 3:
            /* NULL */

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CallIdentifier                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CallIdentifier (OOCTXT* pctxt, H225CallIdentifier* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode guid */

   stat = asn1PD_H225GloballyUniqueID (pctxt, &pvalue->guid);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityServiceMode                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225SecurityServiceMode (OOCTXT* pctxt, H225SecurityServiceMode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H225NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* none */
         case 1:
            /* NULL */

            break;

         /* default_ */
         case 2:
            /* NULL */

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityCapabilities                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225SecurityCapabilities (OOCTXT* pctxt, H225SecurityCapabilities* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardPresent = optbit;

   /* decode nonStandard */

   if (pvalue->m.nonStandardPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandard);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode encryption */

   stat = asn1PD_H225SecurityServiceMode (pctxt, &pvalue->encryption);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode authenticaton */

   stat = asn1PD_H225SecurityServiceMode (pctxt, &pvalue->authenticaton);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode integrity */

   stat = asn1PD_H225SecurityServiceMode (pctxt, &pvalue->integrity);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H245Security                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225H245Security (OOCTXT* pctxt, H225H245Security* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* nonStandard */
         case 0:
            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H225NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* noSecurity */
         case 1:
            /* NULL */

            break;

         /* tls */
         case 2:
            pvalue->u.tls = ALLOC_ASN1ELEM (pctxt, H225SecurityCapabilities);
            if (pvalue->u.tls == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225SecurityCapabilities (pctxt, pvalue->u.tls);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* ipsec */
         case 3:
            pvalue->u.ipsec = ALLOC_ASN1ELEM (pctxt, H225SecurityCapabilities);
            if (pvalue->u.ipsec == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225SecurityCapabilities (pctxt, pvalue->u.ipsec);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH225H245Security                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225_SeqOfH225H245Security (OOCTXT* pctxt, H225_SeqOfH225H245Security* pvalue)
{
   int stat = ASN_OK;
   H225H245Security* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225H245Security);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H225H245Security (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH225ClearToken                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225_SeqOfH225ClearToken (OOCTXT* pctxt, H225_SeqOfH225ClearToken* pvalue)
{
   int stat = ASN_OK;
   H235ClearToken* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H235ClearToken);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H235ClearToken (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CryptoH323Token_cryptoEPPwdHash                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CryptoH323Token_cryptoEPPwdHash (OOCTXT* pctxt, H225CryptoH323Token_cryptoEPPwdHash* pvalue)
{
   int stat = ASN_OK;

   /* decode alias */

   stat = asn1PD_H225AliasAddress (pctxt, &pvalue->alias);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode timeStamp */

   stat = asn1PD_H235TimeStamp (pctxt, &pvalue->timeStamp);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode token */

   stat = asn1PD_H235HASHED (pctxt, &pvalue->token);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GatekeeperIdentifier                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225GatekeeperIdentifier (OOCTXT* pctxt, H225GatekeeperIdentifier* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 128, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeBMPString (pctxt, pvalue, 0);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CryptoH323Token_cryptoGKPwdHash                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CryptoH323Token_cryptoGKPwdHash (OOCTXT* pctxt, H225CryptoH323Token_cryptoGKPwdHash* pvalue)
{
   int stat = ASN_OK;

   /* decode gatekeeperId */

   stat = asn1PD_H225GatekeeperIdentifier (pctxt, &pvalue->gatekeeperId);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode timeStamp */

   stat = asn1PD_H235TimeStamp (pctxt, &pvalue->timeStamp);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode token */

   stat = asn1PD_H235HASHED (pctxt, &pvalue->token);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CryptoH323Token_cryptoEPCert                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CryptoH323Token_cryptoEPCert (OOCTXT* pctxt, H225CryptoH323Token_cryptoEPCert* pvalue)
{
   int stat = ASN_OK;

   /* decode toBeSigned */

   stat = asn1PD_H235EncodedPwdCertToken (pctxt, &pvalue->toBeSigned);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode algorithmOID */

   stat = decodeObjectIdentifier (pctxt, &pvalue->algorithmOID);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode paramS */

   stat = asn1PD_H235Params (pctxt, &pvalue->paramS);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode signature */

   stat = decodeDynBitString (pctxt, (ASN1DynBitStr*)&pvalue->signature);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CryptoH323Token_cryptoGKCert                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CryptoH323Token_cryptoGKCert (OOCTXT* pctxt, H225CryptoH323Token_cryptoGKCert* pvalue)
{
   int stat = ASN_OK;

   /* decode toBeSigned */

   stat = asn1PD_H235EncodedPwdCertToken (pctxt, &pvalue->toBeSigned);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode algorithmOID */

   stat = decodeObjectIdentifier (pctxt, &pvalue->algorithmOID);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode paramS */

   stat = asn1PD_H235Params (pctxt, &pvalue->paramS);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode signature */

   stat = decodeDynBitString (pctxt, (ASN1DynBitStr*)&pvalue->signature);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncodedFastStartToken                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225EncodedFastStartToken (OOCTXT* pctxt, H225EncodedFastStartToken* pvalue)
{
   int stat = ASN_OK;

   stat = decodeOpenType (pctxt, &pvalue->data, &pvalue->numocts);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CryptoH323Token_cryptoFastStart                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CryptoH323Token_cryptoFastStart (OOCTXT* pctxt, H225CryptoH323Token_cryptoFastStart* pvalue)
{
   int stat = ASN_OK;

   /* decode toBeSigned */

   stat = asn1PD_H225EncodedFastStartToken (pctxt, &pvalue->toBeSigned);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode algorithmOID */

   stat = decodeObjectIdentifier (pctxt, &pvalue->algorithmOID);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode paramS */

   stat = asn1PD_H235Params (pctxt, &pvalue->paramS);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode signature */

   stat = decodeDynBitString (pctxt, (ASN1DynBitStr*)&pvalue->signature);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CryptoH323Token                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CryptoH323Token (OOCTXT* pctxt, H225CryptoH323Token* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 7);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* cryptoEPPwdHash */
         case 0:
            pvalue->u.cryptoEPPwdHash = ALLOC_ASN1ELEM (pctxt, H225CryptoH323Token_cryptoEPPwdHash);
            if (pvalue->u.cryptoEPPwdHash == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225CryptoH323Token_cryptoEPPwdHash (pctxt, pvalue->u.cryptoEPPwdHash);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* cryptoGKPwdHash */
         case 1:
            pvalue->u.cryptoGKPwdHash = ALLOC_ASN1ELEM (pctxt, H225CryptoH323Token_cryptoGKPwdHash);
            if (pvalue->u.cryptoGKPwdHash == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225CryptoH323Token_cryptoGKPwdHash (pctxt, pvalue->u.cryptoGKPwdHash);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* cryptoEPPwdEncr */
         case 2:
            pvalue->u.cryptoEPPwdEncr = ALLOC_ASN1ELEM (pctxt, H235ENCRYPTED);
            if (pvalue->u.cryptoEPPwdEncr == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H235ENCRYPTED (pctxt, pvalue->u.cryptoEPPwdEncr);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* cryptoGKPwdEncr */
         case 3:
            pvalue->u.cryptoGKPwdEncr = ALLOC_ASN1ELEM (pctxt, H235ENCRYPTED);
            if (pvalue->u.cryptoGKPwdEncr == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H235ENCRYPTED (pctxt, pvalue->u.cryptoGKPwdEncr);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* cryptoEPCert */
         case 4:
            pvalue->u.cryptoEPCert = ALLOC_ASN1ELEM (pctxt, H225CryptoH323Token_cryptoEPCert);
            if (pvalue->u.cryptoEPCert == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225CryptoH323Token_cryptoEPCert (pctxt, pvalue->u.cryptoEPCert);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* cryptoGKCert */
         case 5:
            pvalue->u.cryptoGKCert = ALLOC_ASN1ELEM (pctxt, H225CryptoH323Token_cryptoGKCert);
            if (pvalue->u.cryptoGKCert == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225CryptoH323Token_cryptoGKCert (pctxt, pvalue->u.cryptoGKCert);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* cryptoFastStart */
         case 6:
            pvalue->u.cryptoFastStart = ALLOC_ASN1ELEM (pctxt, H225CryptoH323Token_cryptoFastStart);
            if (pvalue->u.cryptoFastStart == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225CryptoH323Token_cryptoFastStart (pctxt, pvalue->u.cryptoFastStart);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* nestedcryptoToken */
         case 7:
            pvalue->u.nestedcryptoToken = ALLOC_ASN1ELEM (pctxt, H235CryptoToken);
            if (pvalue->u.nestedcryptoToken == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H235CryptoToken (pctxt, pvalue->u.nestedcryptoToken);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 9;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH225CryptoH323Token                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225_SeqOfH225CryptoH323Token (OOCTXT* pctxt, H225_SeqOfH225CryptoH323Token* pvalue)
{
   int stat = ASN_OK;
   H225CryptoH323Token* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225CryptoH323Token);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H225CryptoH323Token (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Setup_UUIE_fastStart                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Setup_UUIE_fastStart (OOCTXT* pctxt, H225Setup_UUIE_fastStart* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, ASN1DynOctStr);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EndpointIdentifier                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225EndpointIdentifier (OOCTXT* pctxt, H225EndpointIdentifier* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 128, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeBMPString (pctxt, pvalue, 0);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScnConnectionType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225ScnConnectionType (OOCTXT* pctxt, H225ScnConnectionType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 6);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* unknown */
         case 0:
            /* NULL */

            break;

         /* bChannel */
         case 1:
            /* NULL */

            break;

         /* hybrid2x64 */
         case 2:
            /* NULL */

            break;

         /* hybrid384 */
         case 3:
            /* NULL */

            break;

         /* hybrid1536 */
         case 4:
            /* NULL */

            break;

         /* hybrid1920 */
         case 5:
            /* NULL */

            break;

         /* multirate */
         case 6:
            /* NULL */

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 8;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScnConnectionAggregation                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225ScnConnectionAggregation (OOCTXT* pctxt, H225ScnConnectionAggregation* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 5);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* auto_ */
         case 0:
            /* NULL */

            break;

         /* none */
         case 1:
            /* NULL */

            break;

         /* h221 */
         case 2:
            /* NULL */

            break;

         /* bonded_mode1 */
         case 3:
            /* NULL */

            break;

         /* bonded_mode2 */
         case 4:
            /* NULL */

            break;

         /* bonded_mode3 */
         case 5:
            /* NULL */

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 7;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Setup_UUIE_connectionParameters                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Setup_UUIE_connectionParameters (OOCTXT* pctxt, H225Setup_UUIE_connectionParameters* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode connectionType */

   stat = asn1PD_H225ScnConnectionType (pctxt, &pvalue->connectionType);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode numberOfScnConnections */

   stat = decodeConsUInt16 (pctxt, &pvalue->numberOfScnConnections, 0U, 65535U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode connectionAggregation */

   stat = asn1PD_H225ScnConnectionAggregation (pctxt, &pvalue->connectionAggregation);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Setup_UUIE_language                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Setup_UUIE_language (OOCTXT* pctxt, H225Setup_UUIE_language* pvalue)
{
   static Asn1SizeCnst element_lsize1 = { 0, 1, 32, 0 };
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, ASN1IA5String);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = addSizeConstraint (pctxt, &element_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeConstrainedStringEx (pctxt, &pvalue->elem[xx1], 0, 8, 7, 7);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PresentationIndicator                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225PresentationIndicator (OOCTXT* pctxt, H225PresentationIndicator* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* presentationAllowed */
         case 0:
            /* NULL */

            break;

         /* presentationRestricted */
         case 1:
            /* NULL */

            break;

         /* addressNotAvailable */
         case 2:
            /* NULL */

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScreeningIndicator                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225ScreeningIndicator (OOCTXT* pctxt, H225ScreeningIndicator* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      *pvalue = ui;
   }
   else {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = userProvidedNotScreened; break;
         case 1: *pvalue = userProvidedVerifiedAndPassed; break;
         case 2: *pvalue = userProvidedVerifiedAndFailed; break;
         case 3: *pvalue = networkProvided; break;
         default: return LOG_ASN1ERR (pctxt, ASN_E_INVENUM);
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H248SignalsDescriptor                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225H248SignalsDescriptor (OOCTXT* pctxt, H225H248SignalsDescriptor* pvalue)
{
   int stat = ASN_OK;

   stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CallCreditServiceControl_billingMode                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CallCreditServiceControl_billingMode (OOCTXT* pctxt, H225CallCreditServiceControl_billingMode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* credit */
         case 0:
            /* NULL */

            break;

         /* debit */
         case 1:
            /* NULL */

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CallCreditServiceControl_callStartingPoint                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CallCreditServiceControl_callStartingPoint (OOCTXT* pctxt, H225CallCreditServiceControl_callStartingPoint* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* alerting */
         case 0:
            /* NULL */

            break;

         /* connect */
         case 1:
            /* NULL */

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 3;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CallCreditServiceControl                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CallCreditServiceControl (OOCTXT* pctxt, H225CallCreditServiceControl* pvalue)
{
   static Asn1SizeCnst amountString_lsize1 = { 0, 1, 512, 0 };
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.amountStringPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.billingModePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.callDurationLimitPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.enforceCallDurationLimitPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.callStartingPointPresent = optbit;

   /* decode amountString */

   if (pvalue->m.amountStringPresent) {
      stat = addSizeConstraint (pctxt, &amountString_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeBMPString (pctxt, &pvalue->amountString, 0);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode billingMode */

   if (pvalue->m.billingModePresent) {
      stat = asn1PD_H225CallCreditServiceControl_billingMode (pctxt, &pvalue->billingMode);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode callDurationLimit */

   if (pvalue->m.callDurationLimitPresent) {
      stat = decodeConsUnsigned (pctxt, &pvalue->callDurationLimit, 1U, ASN1UINT_MAX);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode enforceCallDurationLimit */

   if (pvalue->m.enforceCallDurationLimitPresent) {
      stat = DECODEBIT (pctxt, &pvalue->enforceCallDurationLimit);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode callStartingPoint */

   if (pvalue->m.callStartingPointPresent) {
      stat = asn1PD_H225CallCreditServiceControl_callStartingPoint (pctxt, &pvalue->callStartingPoint);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceControlDescriptor                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225ServiceControlDescriptor (OOCTXT* pctxt, H225ServiceControlDescriptor* pvalue)
{
   static Asn1SizeCnst url_lsize1 = { 0, 0, 512, 0 };
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* url */
         case 0:
            stat = addSizeConstraint (pctxt, &url_lsize1);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            stat = decodeConstrainedStringEx (pctxt, &pvalue->u.url, 0, 8, 7, 7);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* signal */
         case 1:
            pvalue->u.signal = ALLOC_ASN1ELEM (pctxt, H225H248SignalsDescriptor);
            if (pvalue->u.signal == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225H248SignalsDescriptor (pctxt, pvalue->u.signal);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* nonStandard */
         case 2:
            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H225NonStandardParameter);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225NonStandardParameter (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* callCreditServiceControl */
         case 3:
            pvalue->u.callCreditServiceControl = ALLOC_ASN1ELEM (pctxt, H225CallCreditServiceControl);
            if (pvalue->u.callCreditServiceControl == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225CallCreditServiceControl (pctxt, pvalue->u.callCreditServiceControl);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceControlSession_reason                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225ServiceControlSession_reason (OOCTXT* pctxt, H225ServiceControlSession_reason* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* open */
         case 0:
            /* NULL */

            break;

         /* refresh */
         case 1:
            /* NULL */

            break;

         /* close */
         case 2:
            /* NULL */

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceControlSession                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225ServiceControlSession (OOCTXT* pctxt, H225ServiceControlSession* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.contentsPresent = optbit;

   /* decode sessionId */

   stat = decodeConsUInt8 (pctxt, &pvalue->sessionId, 0U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode contents */

   if (pvalue->m.contentsPresent) {
      stat = asn1PD_H225ServiceControlDescriptor (pctxt, &pvalue->contents);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode reason */

   stat = asn1PD_H225ServiceControlSession_reason (pctxt, &pvalue->reason);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH225ServiceControlSession                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225_SeqOfH225ServiceControlSession (OOCTXT* pctxt, H225_SeqOfH225ServiceControlSession* pvalue)
{
   int stat = ASN_OK;
   H225ServiceControlSession* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225ServiceControlSession);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H225ServiceControlSession (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CarrierInfo_carrierIdentificationCode                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CarrierInfo_carrierIdentificationCode (OOCTXT* pctxt, H225CarrierInfo_carrierIdentificationCode* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 3, 4, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CarrierInfo                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CarrierInfo (OOCTXT* pctxt, H225CarrierInfo* pvalue)
{
   static Asn1SizeCnst carrierName_lsize1 = { 0, 1, 128, 0 };
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.carrierIdentificationCodePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.carrierNamePresent = optbit;

   /* decode carrierIdentificationCode */

   if (pvalue->m.carrierIdentificationCodePresent) {
      stat = asn1PD_H225CarrierInfo_carrierIdentificationCode (pctxt, &pvalue->carrierIdentificationCode);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode carrierName */

   if (pvalue->m.carrierNamePresent) {
      stat = addSizeConstraint (pctxt, &carrierName_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeConstrainedStringEx (pctxt, &pvalue->carrierName, 0, 8, 7, 7);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CallsAvailable                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CallsAvailable (OOCTXT* pctxt, H225CallsAvailable* pvalue)
{
   static Asn1SizeCnst group_lsize1 = { 0, 1, 128, 0 };
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.groupPresent = optbit;

   /* decode calls */

   stat = decodeConsUnsigned (pctxt, &pvalue->calls, 0U, ASN1UINT_MAX);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode group */

   if (pvalue->m.groupPresent) {
      stat = addSizeConstraint (pctxt, &group_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeConstrainedStringEx (pctxt, &pvalue->group, 0, 8, 7, 7);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 1 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.carrierPresent = 1;

                     stat = asn1PD_H225CarrierInfo (pctxt, &pvalue->carrier);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH225CallsAvailable                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225_SeqOfH225CallsAvailable (OOCTXT* pctxt, H225_SeqOfH225CallsAvailable* pvalue)
{
   int stat = ASN_OK;
   H225CallsAvailable* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225CallsAvailable);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H225CallsAvailable (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CallCapacityInfo                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CallCapacityInfo (OOCTXT* pctxt, H225CallCapacityInfo* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.voiceGwCallsAvailablePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.h310GwCallsAvailablePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.h320GwCallsAvailablePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.h321GwCallsAvailablePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.h322GwCallsAvailablePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.h323GwCallsAvailablePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.h324GwCallsAvailablePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.t120OnlyGwCallsAvailablePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.t38FaxAnnexbOnlyGwCallsAvailablePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.terminalCallsAvailablePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.mcuCallsAvailablePresent = optbit;

   /* decode voiceGwCallsAvailable */

   if (pvalue->m.voiceGwCallsAvailablePresent) {
      stat = asn1PD_H225_SeqOfH225CallsAvailable (pctxt, &pvalue->voiceGwCallsAvailable);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode h310GwCallsAvailable */

   if (pvalue->m.h310GwCallsAvailablePresent) {
      stat = asn1PD_H225_SeqOfH225CallsAvailable (pctxt, &pvalue->h310GwCallsAvailable);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode h320GwCallsAvailable */

   if (pvalue->m.h320GwCallsAvailablePresent) {
      stat = asn1PD_H225_SeqOfH225CallsAvailable (pctxt, &pvalue->h320GwCallsAvailable);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode h321GwCallsAvailable */

   if (pvalue->m.h321GwCallsAvailablePresent) {
      stat = asn1PD_H225_SeqOfH225CallsAvailable (pctxt, &pvalue->h321GwCallsAvailable);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode h322GwCallsAvailable */

   if (pvalue->m.h322GwCallsAvailablePresent) {
      stat = asn1PD_H225_SeqOfH225CallsAvailable (pctxt, &pvalue->h322GwCallsAvailable);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode h323GwCallsAvailable */

   if (pvalue->m.h323GwCallsAvailablePresent) {
      stat = asn1PD_H225_SeqOfH225CallsAvailable (pctxt, &pvalue->h323GwCallsAvailable);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode h324GwCallsAvailable */

   if (pvalue->m.h324GwCallsAvailablePresent) {
      stat = asn1PD_H225_SeqOfH225CallsAvailable (pctxt, &pvalue->h324GwCallsAvailable);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode t120OnlyGwCallsAvailable */

   if (pvalue->m.t120OnlyGwCallsAvailablePresent) {
      stat = asn1PD_H225_SeqOfH225CallsAvailable (pctxt, &pvalue->t120OnlyGwCallsAvailable);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode t38FaxAnnexbOnlyGwCallsAvailable */

   if (pvalue->m.t38FaxAnnexbOnlyGwCallsAvailablePresent) {
      stat = asn1PD_H225_SeqOfH225CallsAvailable (pctxt, &pvalue->t38FaxAnnexbOnlyGwCallsAvailable);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode terminalCallsAvailable */

   if (pvalue->m.terminalCallsAvailablePresent) {
      stat = asn1PD_H225_SeqOfH225CallsAvailable (pctxt, &pvalue->terminalCallsAvailable);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode mcuCallsAvailable */

   if (pvalue->m.mcuCallsAvailablePresent) {
      stat = asn1PD_H225_SeqOfH225CallsAvailable (pctxt, &pvalue->mcuCallsAvailable);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 1 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.sipGwCallsAvailablePresent = 1;

                     stat = asn1PD_H225_SeqOfH225CallsAvailable (pctxt, &pvalue->sipGwCallsAvailable);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CallCapacity                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CallCapacity (OOCTXT* pctxt, H225CallCapacity* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.maximumCallCapacityPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.currentCallCapacityPresent = optbit;

   /* decode maximumCallCapacity */

   if (pvalue->m.maximumCallCapacityPresent) {
      stat = asn1PD_H225CallCapacityInfo (pctxt, &pvalue->maximumCallCapacity);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode currentCallCapacity */

   if (pvalue->m.currentCallCapacityPresent) {
      stat = asn1PD_H225CallCapacityInfo (pctxt, &pvalue->currentCallCapacity);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CicInfo_cic_element                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CicInfo_cic_element (OOCTXT* pctxt, H225CicInfo_cic_element* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 2, 4, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH225CicInfo_cic_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225_SeqOfH225CicInfo_cic_element (OOCTXT* pctxt, H225_SeqOfH225CicInfo_cic_element* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, H225CicInfo_cic_element);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_H225CicInfo_cic_element (pctxt, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CicInfo_pointCode                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CicInfo_pointCode (OOCTXT* pctxt, H225CicInfo_pointCode* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 2, 5, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CicInfo                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CicInfo (OOCTXT* pctxt, H225CicInfo* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode cic */

   stat = asn1PD_H225_SeqOfH225CicInfo_cic_element (pctxt, &pvalue->cic);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode pointCode */

   stat = asn1PD_H225CicInfo_pointCode (pctxt, &pvalue->pointCode);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GroupID_member                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225GroupID_member (OOCTXT* pctxt, H225GroupID_member* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, ASN1USINT);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = decodeConsUInt16 (pctxt, &pvalue->elem[xx1], 0U, 65535U);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GroupID                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225GroupID (OOCTXT* pctxt, H225GroupID* pvalue)
{
   static Asn1SizeCnst group_lsize1 = { 0, 1, 128, 0 };
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.memberPresent = optbit;

   /* decode member */

   if (pvalue->m.memberPresent) {
      stat = asn1PD_H225GroupID_member (pctxt, &pvalue->member);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode group */

   stat = addSizeConstraint (pctxt, &group_lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeConstrainedStringEx (pctxt, &pvalue->group, 0, 8, 7, 7);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CircuitIdentifier                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CircuitIdentifier (OOCTXT* pctxt, H225CircuitIdentifier* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cicPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.groupPresent = optbit;

   /* decode cic */

   if (pvalue->m.cicPresent) {
      stat = asn1PD_H225CicInfo (pctxt, &pvalue->cic);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode group */

   if (pvalue->m.groupPresent) {
      stat = asn1PD_H225GroupID (pctxt, &pvalue->group);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 1 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.carrierPresent = 1;

                     stat = asn1PD_H225CarrierInfo (pctxt, &pvalue->carrier);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GenericIdentifier                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225GenericIdentifier (OOCTXT* pctxt, H225GenericIdentifier* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 2);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* standard */
         case 0:
            /* extension bit */

            stat = DECODEBIT (pctxt, &extbit);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (extbit == 0) {
               stat = decodeConsInteger (pctxt, &pvalue->u.standard, 0, 16383);
               if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            }
            else {
               stat = decodeUnconsInteger (pctxt, &pvalue->u.standard);
               if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            }

            break;

         /* oid */
         case 1:
            pvalue->u.oid = ALLOC_ASN1ELEM (pctxt, ASN1OBJID);
            if (pvalue->u.oid == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = decodeObjectIdentifier (pctxt, pvalue->u.oid);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* nonStandard */
         case 2:
            pvalue->u.nonStandard = ALLOC_ASN1ELEM (pctxt, H225GloballyUniqueID);
            if (pvalue->u.nonStandard == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225GloballyUniqueID (pctxt, pvalue->u.nonStandard);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 4;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Content_compound                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Content_compound (OOCTXT* pctxt, H225Content_compound* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 512, 0 };
   int stat = ASN_OK;
   H225EnumeratedParameter* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225EnumeratedParameter);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H225EnumeratedParameter (pctxt, (H225EnumeratedParameter*)pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Content_nested                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Content_nested (OOCTXT* pctxt, H225Content_nested* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 16, 0 };
   int stat = ASN_OK;
   H225GenericData* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225GenericData);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H225GenericData (pctxt, (H225GenericData*)pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Content                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Content (OOCTXT* pctxt, H225Content* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 11);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* raw */
         case 0:
            pvalue->u.raw = ALLOC_ASN1ELEM (pctxt, ASN1DynOctStr);
            if (pvalue->u.raw == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)pvalue->u.raw);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* text */
         case 1:
            stat = decodeConstrainedStringEx (pctxt, &pvalue->u.text, 0, 8, 7, 7);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* unicode */
         case 2:
            stat = decodeBMPString (pctxt, &pvalue->u.unicode, 0);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* bool_ */
         case 3:
            stat = DECODEBIT (pctxt, &pvalue->u.bool_);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* number8 */
         case 4:
            stat = decodeConsUInt8 (pctxt, &pvalue->u.number8, 0U, 255U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* number16 */
         case 5:
            stat = decodeConsUInt16 (pctxt, &pvalue->u.number16, 0U, 65535U);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* number32 */
         case 6:
            stat = decodeConsUnsigned (pctxt, &pvalue->u.number32, 0U, ASN1UINT_MAX);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* id */
         case 7:
            pvalue->u.id = ALLOC_ASN1ELEM (pctxt, H225GenericIdentifier);
            if (pvalue->u.id == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225GenericIdentifier (pctxt, pvalue->u.id);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* alias */
         case 8:
            pvalue->u.alias = ALLOC_ASN1ELEM (pctxt, H225AliasAddress);
            if (pvalue->u.alias == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225AliasAddress (pctxt, pvalue->u.alias);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* transport */
         case 9:
            pvalue->u.transport = ALLOC_ASN1ELEM (pctxt, H225TransportAddress);
            if (pvalue->u.transport == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225TransportAddress (pctxt, pvalue->u.transport);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* compound */
         case 10:
            pvalue->u.compound = ALLOC_ASN1ELEM (pctxt, H225Content_compound);
            if (pvalue->u.compound == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225Content_compound (pctxt, pvalue->u.compound);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* nested */
         case 11:
            pvalue->u.nested = ALLOC_ASN1ELEM (pctxt, H225Content_nested);
            if (pvalue->u.nested == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225Content_nested (pctxt, pvalue->u.nested);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 13;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EnumeratedParameter                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225EnumeratedParameter (OOCTXT* pctxt, H225EnumeratedParameter* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.contentPresent = optbit;

   /* decode id */

   stat = asn1PD_H225GenericIdentifier (pctxt, &pvalue->id);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode content */

   if (pvalue->m.contentPresent) {
      stat = asn1PD_H225Content (pctxt, &pvalue->content);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GenericData_parameters                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225GenericData_parameters (OOCTXT* pctxt, H225GenericData_parameters* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 512, 0 };
   int stat = ASN_OK;
   H225EnumeratedParameter* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeLength (pctxt, &count);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   dListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225EnumeratedParameter);
      if (pdata == NULL)
         return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

      stat = asn1PD_H225EnumeratedParameter (pctxt, pdata);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      dListAppendNode (pctxt, pvalue, pdata);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GenericData                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225GenericData (OOCTXT* pctxt, H225GenericData* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.parametersPresent = optbit;

   /* decode id */

   stat = asn1PD_H225GenericIdentifier (pctxt, &pvalue->id);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode parameters */

   if (pvalue->m.parametersPresent) {
      stat = asn1PD_H225GenericData_parameters (pctxt, &pvalue->parameters);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH225GenericData                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225_SeqOfH225GenericData (OOCTXT* pctxt, H225_SeqOfH225GenericData* pvalue)
{
   int stat = ASN_OK;
   H225GenericData* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225GenericData);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H225GenericData (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CircuitInfo                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CircuitInfo (OOCTXT* pctxt, H225CircuitInfo* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sourceCircuitIDPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.destinationCircuitIDPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.genericDataPresent = optbit;

   /* decode sourceCircuitID */

   if (pvalue->m.sourceCircuitIDPresent) {
      stat = asn1PD_H225CircuitIdentifier (pctxt, &pvalue->sourceCircuitID);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode destinationCircuitID */

   if (pvalue->m.destinationCircuitIDPresent) {
      stat = asn1PD_H225CircuitIdentifier (pctxt, &pvalue->destinationCircuitID);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode genericData */

   if (pvalue->m.genericDataPresent) {
      stat = asn1PD_H225_SeqOfH225GenericData (pctxt, &pvalue->genericData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureDescriptor                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225FeatureDescriptor (OOCTXT* pctxt, H225FeatureDescriptor* pvalue)
{
   int stat = ASN_OK;

   stat = asn1PD_H225GenericData (pctxt, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH225FeatureDescriptor                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225_SeqOfH225FeatureDescriptor (OOCTXT* pctxt, H225_SeqOfH225FeatureDescriptor* pvalue)
{
   int stat = ASN_OK;
   H225FeatureDescriptor* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225FeatureDescriptor);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H225FeatureDescriptor (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Setup_UUIE_parallelH245Control                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Setup_UUIE_parallelH245Control (OOCTXT* pctxt, H225Setup_UUIE_parallelH245Control* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, ASN1DynOctStr);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExtendedAliasAddress                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225ExtendedAliasAddress (OOCTXT* pctxt, H225ExtendedAliasAddress* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.presentationIndicatorPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.screeningIndicatorPresent = optbit;

   /* decode address */

   stat = asn1PD_H225AliasAddress (pctxt, &pvalue->address);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode presentationIndicator */

   if (pvalue->m.presentationIndicatorPresent) {
      stat = asn1PD_H225PresentationIndicator (pctxt, &pvalue->presentationIndicator);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode screeningIndicator */

   if (pvalue->m.screeningIndicatorPresent) {
      stat = asn1PD_H225ScreeningIndicator (pctxt, &pvalue->screeningIndicator);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH225ExtendedAliasAddress                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225_SeqOfH225ExtendedAliasAddress (OOCTXT* pctxt, H225_SeqOfH225ExtendedAliasAddress* pvalue)
{
   int stat = ASN_OK;
   H225ExtendedAliasAddress* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225ExtendedAliasAddress);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H225ExtendedAliasAddress (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Setup_UUIE                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Setup_UUIE (OOCTXT* pctxt, H225Setup_UUIE* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.h245AddressPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.sourceAddressPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.destinationAddressPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.destCallSignalAddressPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.destExtraCallInfoPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.destExtraCRVPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.callServicesPresent = optbit;

   /* decode protocolIdentifier */

   stat = asn1PD_H225ProtocolIdentifier (pctxt, &pvalue->protocolIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode h245Address */

   if (pvalue->m.h245AddressPresent) {
      stat = asn1PD_H225TransportAddress (pctxt, &pvalue->h245Address);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode sourceAddress */

   if (pvalue->m.sourceAddressPresent) {
      stat = asn1PD_H225_SeqOfH225AliasAddress (pctxt, &pvalue->sourceAddress);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode sourceInfo */

   stat = asn1PD_H225EndpointType (pctxt, &pvalue->sourceInfo);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode destinationAddress */

   if (pvalue->m.destinationAddressPresent) {
      stat = asn1PD_H225_SeqOfH225AliasAddress (pctxt, &pvalue->destinationAddress);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode destCallSignalAddress */

   if (pvalue->m.destCallSignalAddressPresent) {
      stat = asn1PD_H225TransportAddress (pctxt, &pvalue->destCallSignalAddress);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode destExtraCallInfo */

   if (pvalue->m.destExtraCallInfoPresent) {
      stat = asn1PD_H225_SeqOfH225AliasAddress (pctxt, &pvalue->destExtraCallInfo);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode destExtraCRV */

   if (pvalue->m.destExtraCRVPresent) {
      stat = asn1PD_H225_SeqOfH225CallReferenceValue (pctxt, &pvalue->destExtraCRV);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode activeMC */

   stat = DECODEBIT (pctxt, &pvalue->activeMC);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode conferenceID */

   stat = asn1PD_H225ConferenceIdentifier (pctxt, &pvalue->conferenceID);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode conferenceGoal */

   stat = asn1PD_H225Setup_UUIE_conferenceGoal (pctxt, &pvalue->conferenceGoal);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode callServices */

   if (pvalue->m.callServicesPresent) {
      stat = asn1PD_H225QseriesOptions (pctxt, &pvalue->callServices);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode callType */

   stat = asn1PD_H225CallType (pctxt, &pvalue->callType);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 27 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.sourceCallSignalAddressPresent = 1;

                     stat = asn1PD_H225TransportAddress (pctxt, &pvalue->sourceCallSignalAddress);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 1:
                     pvalue->m.remoteExtensionAddressPresent = 1;

                     stat = asn1PD_H225AliasAddress (pctxt, &pvalue->remoteExtensionAddress);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 2:
                     pvalue->m.callIdentifierPresent = 1;

                     stat = asn1PD_H225CallIdentifier (pctxt, &pvalue->callIdentifier);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 3:
                     pvalue->m.h245SecurityCapabilityPresent = 1;

                     stat = asn1PD_H225_SeqOfH225H245Security (pctxt, &pvalue->h245SecurityCapability);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 4:
                     pvalue->m.tokensPresent = 1;

                     stat = asn1PD_H225_SeqOfH225ClearToken (pctxt, &pvalue->tokens);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 5:
                     pvalue->m.cryptoTokensPresent = 1;

                     stat = asn1PD_H225_SeqOfH225CryptoH323Token (pctxt, &pvalue->cryptoTokens);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 6:
                     pvalue->m.fastStartPresent = 1;

                     stat = asn1PD_H225Setup_UUIE_fastStart (pctxt, &pvalue->fastStart);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 7:
                     pvalue->m.mediaWaitForConnectPresent = 1;

                     stat = DECODEBIT (pctxt, &pvalue->mediaWaitForConnect);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 8:
                     pvalue->m.canOverlapSendPresent = 1;

                     stat = DECODEBIT (pctxt, &pvalue->canOverlapSend);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 9:
                     pvalue->m.endpointIdentifierPresent = 1;

                     stat = asn1PD_H225EndpointIdentifier (pctxt, &pvalue->endpointIdentifier);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 10:
                     pvalue->m.multipleCallsPresent = 1;

                     stat = DECODEBIT (pctxt, &pvalue->multipleCalls);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 11:
                     pvalue->m.maintainConnectionPresent = 1;

                     stat = DECODEBIT (pctxt, &pvalue->maintainConnection);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 12:
                     pvalue->m.connectionParametersPresent = 1;

                     stat = asn1PD_H225Setup_UUIE_connectionParameters (pctxt, &pvalue->connectionParameters);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 13:
                     pvalue->m.languagePresent = 1;

                     stat = asn1PD_H225Setup_UUIE_language (pctxt, &pvalue->language);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 14:
                     pvalue->m.presentationIndicatorPresent = 1;

                     stat = asn1PD_H225PresentationIndicator (pctxt, &pvalue->presentationIndicator);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 15:
                     pvalue->m.screeningIndicatorPresent = 1;

                     stat = asn1PD_H225ScreeningIndicator (pctxt, &pvalue->screeningIndicator);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 16:
                     pvalue->m.serviceControlPresent = 1;

                     stat = asn1PD_H225_SeqOfH225ServiceControlSession (pctxt, &pvalue->serviceControl);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 17:
                     pvalue->m.symmetricOperationRequiredPresent = 1;

                     /* NULL */
                     break;

                  case 18:
                     pvalue->m.capacityPresent = 1;

                     stat = asn1PD_H225CallCapacity (pctxt, &pvalue->capacity);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 19:
                     pvalue->m.circuitInfoPresent = 1;

                     stat = asn1PD_H225CircuitInfo (pctxt, &pvalue->circuitInfo);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 20:
                     pvalue->m.desiredProtocolsPresent = 1;

                     stat = asn1PD_H225_SeqOfH225SupportedProtocols (pctxt, &pvalue->desiredProtocols);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 21:
                     pvalue->m.neededFeaturesPresent = 1;

                     stat = asn1PD_H225_SeqOfH225FeatureDescriptor (pctxt, &pvalue->neededFeatures);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 22:
                     pvalue->m.desiredFeaturesPresent = 1;

                     stat = asn1PD_H225_SeqOfH225FeatureDescriptor (pctxt, &pvalue->desiredFeatures);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 23:
                     pvalue->m.supportedFeaturesPresent = 1;

                     stat = asn1PD_H225_SeqOfH225FeatureDescriptor (pctxt, &pvalue->supportedFeatures);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 24:
                     pvalue->m.parallelH245ControlPresent = 1;

                     stat = asn1PD_H225Setup_UUIE_parallelH245Control (pctxt, &pvalue->parallelH245Control);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 25:
                     pvalue->m.additionalSourceAddressesPresent = 1;

                     stat = asn1PD_H225_SeqOfH225ExtendedAliasAddress (pctxt, &pvalue->additionalSourceAddresses);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 26:
                     pvalue->m.hopCountPresent = 1;

                     stat = decodeConsUInt8 (pctxt, &pvalue->hopCount, 1U, 31U);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CallProceeding_UUIE_fastStart                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CallProceeding_UUIE_fastStart (OOCTXT* pctxt, H225CallProceeding_UUIE_fastStart* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, ASN1DynOctStr);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FeatureSet                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225FeatureSet (OOCTXT* pctxt, H225FeatureSet* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.neededFeaturesPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.desiredFeaturesPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.supportedFeaturesPresent = optbit;

   /* decode replacementFeatureSet */

   stat = DECODEBIT (pctxt, &pvalue->replacementFeatureSet);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode neededFeatures */

   if (pvalue->m.neededFeaturesPresent) {
      stat = asn1PD_H225_SeqOfH225FeatureDescriptor (pctxt, &pvalue->neededFeatures);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode desiredFeatures */

   if (pvalue->m.desiredFeaturesPresent) {
      stat = asn1PD_H225_SeqOfH225FeatureDescriptor (pctxt, &pvalue->desiredFeatures);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode supportedFeatures */

   if (pvalue->m.supportedFeaturesPresent) {
      stat = asn1PD_H225_SeqOfH225FeatureDescriptor (pctxt, &pvalue->supportedFeatures);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CallProceeding_UUIE                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CallProceeding_UUIE (OOCTXT* pctxt, H225CallProceeding_UUIE* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.h245AddressPresent = optbit;

   /* decode protocolIdentifier */

   stat = asn1PD_H225ProtocolIdentifier (pctxt, &pvalue->protocolIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode destinationInfo */

   stat = asn1PD_H225EndpointType (pctxt, &pvalue->destinationInfo);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode h245Address */

   if (pvalue->m.h245AddressPresent) {
      stat = asn1PD_H225TransportAddress (pctxt, &pvalue->h245Address);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 9 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.callIdentifierPresent = 1;

                     stat = asn1PD_H225CallIdentifier (pctxt, &pvalue->callIdentifier);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 1:
                     pvalue->m.h245SecurityModePresent = 1;

                     stat = asn1PD_H225H245Security (pctxt, &pvalue->h245SecurityMode);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 2:
                     pvalue->m.tokensPresent = 1;

                     stat = asn1PD_H225_SeqOfH225ClearToken (pctxt, &pvalue->tokens);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 3:
                     pvalue->m.cryptoTokensPresent = 1;

                     stat = asn1PD_H225_SeqOfH225CryptoH323Token (pctxt, &pvalue->cryptoTokens);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 4:
                     pvalue->m.fastStartPresent = 1;

                     stat = asn1PD_H225CallProceeding_UUIE_fastStart (pctxt, &pvalue->fastStart);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 5:
                     pvalue->m.multipleCallsPresent = 1;

                     stat = DECODEBIT (pctxt, &pvalue->multipleCalls);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 6:
                     pvalue->m.maintainConnectionPresent = 1;

                     stat = DECODEBIT (pctxt, &pvalue->maintainConnection);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 7:
                     pvalue->m.fastConnectRefusedPresent = 1;

                     /* NULL */
                     break;

                  case 8:
                     pvalue->m.featureSetPresent = 1;

                     stat = asn1PD_H225FeatureSet (pctxt, &pvalue->featureSet);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Connect_UUIE_fastStart                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Connect_UUIE_fastStart (OOCTXT* pctxt, H225Connect_UUIE_fastStart* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, ASN1DynOctStr);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Connect_UUIE_language                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Connect_UUIE_language (OOCTXT* pctxt, H225Connect_UUIE_language* pvalue)
{
   static Asn1SizeCnst element_lsize1 = { 0, 1, 32, 0 };
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, ASN1IA5String);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = addSizeConstraint (pctxt, &element_lsize1);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeConstrainedStringEx (pctxt, &pvalue->elem[xx1], 0, 8, 7, 7);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Connect_UUIE                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Connect_UUIE (OOCTXT* pctxt, H225Connect_UUIE* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.h245AddressPresent = optbit;

   /* decode protocolIdentifier */

   stat = asn1PD_H225ProtocolIdentifier (pctxt, &pvalue->protocolIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode h245Address */

   if (pvalue->m.h245AddressPresent) {
      stat = asn1PD_H225TransportAddress (pctxt, &pvalue->h245Address);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode destinationInfo */

   stat = asn1PD_H225EndpointType (pctxt, &pvalue->destinationInfo);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode conferenceID */

   stat = asn1PD_H225ConferenceIdentifier (pctxt, &pvalue->conferenceID);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 15 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.callIdentifierPresent = 1;

                     stat = asn1PD_H225CallIdentifier (pctxt, &pvalue->callIdentifier);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 1:
                     pvalue->m.h245SecurityModePresent = 1;

                     stat = asn1PD_H225H245Security (pctxt, &pvalue->h245SecurityMode);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 2:
                     pvalue->m.tokensPresent = 1;

                     stat = asn1PD_H225_SeqOfH225ClearToken (pctxt, &pvalue->tokens);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 3:
                     pvalue->m.cryptoTokensPresent = 1;

                     stat = asn1PD_H225_SeqOfH225CryptoH323Token (pctxt, &pvalue->cryptoTokens);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 4:
                     pvalue->m.fastStartPresent = 1;

                     stat = asn1PD_H225Connect_UUIE_fastStart (pctxt, &pvalue->fastStart);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 5:
                     pvalue->m.multipleCallsPresent = 1;

                     stat = DECODEBIT (pctxt, &pvalue->multipleCalls);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 6:
                     pvalue->m.maintainConnectionPresent = 1;

                     stat = DECODEBIT (pctxt, &pvalue->maintainConnection);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 7:
                     pvalue->m.languagePresent = 1;

                     stat = asn1PD_H225Connect_UUIE_language (pctxt, &pvalue->language);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 8:
                     pvalue->m.connectedAddressPresent = 1;

                     stat = asn1PD_H225_SeqOfH225AliasAddress (pctxt, &pvalue->connectedAddress);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 9:
                     pvalue->m.presentationIndicatorPresent = 1;

                     stat = asn1PD_H225PresentationIndicator (pctxt, &pvalue->presentationIndicator);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 10:
                     pvalue->m.screeningIndicatorPresent = 1;

                     stat = asn1PD_H225ScreeningIndicator (pctxt, &pvalue->screeningIndicator);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 11:
                     pvalue->m.fastConnectRefusedPresent = 1;

                     /* NULL */
                     break;

                  case 12:
                     pvalue->m.serviceControlPresent = 1;

                     stat = asn1PD_H225_SeqOfH225ServiceControlSession (pctxt, &pvalue->serviceControl);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 13:
                     pvalue->m.capacityPresent = 1;

                     stat = asn1PD_H225CallCapacity (pctxt, &pvalue->capacity);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 14:
                     pvalue->m.featureSetPresent = 1;

                     stat = asn1PD_H225FeatureSet (pctxt, &pvalue->featureSet);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alerting_UUIE_fastStart                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Alerting_UUIE_fastStart (OOCTXT* pctxt, H225Alerting_UUIE_fastStart* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, ASN1DynOctStr);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Alerting_UUIE                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Alerting_UUIE (OOCTXT* pctxt, H225Alerting_UUIE* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.h245AddressPresent = optbit;

   /* decode protocolIdentifier */

   stat = asn1PD_H225ProtocolIdentifier (pctxt, &pvalue->protocolIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode destinationInfo */

   stat = asn1PD_H225EndpointType (pctxt, &pvalue->destinationInfo);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode h245Address */

   if (pvalue->m.h245AddressPresent) {
      stat = asn1PD_H225TransportAddress (pctxt, &pvalue->h245Address);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 14 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.callIdentifierPresent = 1;

                     stat = asn1PD_H225CallIdentifier (pctxt, &pvalue->callIdentifier);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 1:
                     pvalue->m.h245SecurityModePresent = 1;

                     stat = asn1PD_H225H245Security (pctxt, &pvalue->h245SecurityMode);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 2:
                     pvalue->m.tokensPresent = 1;

                     stat = asn1PD_H225_SeqOfH225ClearToken (pctxt, &pvalue->tokens);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 3:
                     pvalue->m.cryptoTokensPresent = 1;

                     stat = asn1PD_H225_SeqOfH225CryptoH323Token (pctxt, &pvalue->cryptoTokens);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 4:
                     pvalue->m.fastStartPresent = 1;

                     stat = asn1PD_H225Alerting_UUIE_fastStart (pctxt, &pvalue->fastStart);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 5:
                     pvalue->m.multipleCallsPresent = 1;

                     stat = DECODEBIT (pctxt, &pvalue->multipleCalls);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 6:
                     pvalue->m.maintainConnectionPresent = 1;

                     stat = DECODEBIT (pctxt, &pvalue->maintainConnection);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 7:
                     pvalue->m.alertingAddressPresent = 1;

                     stat = asn1PD_H225_SeqOfH225AliasAddress (pctxt, &pvalue->alertingAddress);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 8:
                     pvalue->m.presentationIndicatorPresent = 1;

                     stat = asn1PD_H225PresentationIndicator (pctxt, &pvalue->presentationIndicator);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 9:
                     pvalue->m.screeningIndicatorPresent = 1;

                     stat = asn1PD_H225ScreeningIndicator (pctxt, &pvalue->screeningIndicator);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 10:
                     pvalue->m.fastConnectRefusedPresent = 1;

                     /* NULL */
                     break;

                  case 11:
                     pvalue->m.serviceControlPresent = 1;

                     stat = asn1PD_H225_SeqOfH225ServiceControlSession (pctxt, &pvalue->serviceControl);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 12:
                     pvalue->m.capacityPresent = 1;

                     stat = asn1PD_H225CallCapacity (pctxt, &pvalue->capacity);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 13:
                     pvalue->m.featureSetPresent = 1;

                     stat = asn1PD_H225FeatureSet (pctxt, &pvalue->featureSet);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Information_UUIE_fastStart                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Information_UUIE_fastStart (OOCTXT* pctxt, H225Information_UUIE_fastStart* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, ASN1DynOctStr);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Information_UUIE                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Information_UUIE (OOCTXT* pctxt, H225Information_UUIE* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode protocolIdentifier */

   stat = asn1PD_H225ProtocolIdentifier (pctxt, &pvalue->protocolIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 6 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.callIdentifierPresent = 1;

                     stat = asn1PD_H225CallIdentifier (pctxt, &pvalue->callIdentifier);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 1:
                     pvalue->m.tokensPresent = 1;

                     stat = asn1PD_H225_SeqOfH225ClearToken (pctxt, &pvalue->tokens);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 2:
                     pvalue->m.cryptoTokensPresent = 1;

                     stat = asn1PD_H225_SeqOfH225CryptoH323Token (pctxt, &pvalue->cryptoTokens);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 3:
                     pvalue->m.fastStartPresent = 1;

                     stat = asn1PD_H225Information_UUIE_fastStart (pctxt, &pvalue->fastStart);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 4:
                     pvalue->m.fastConnectRefusedPresent = 1;

                     /* NULL */
                     break;

                  case 5:
                     pvalue->m.circuitInfoPresent = 1;

                     stat = asn1PD_H225CircuitInfo (pctxt, &pvalue->circuitInfo);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SecurityErrors                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225SecurityErrors (OOCTXT* pctxt, H225SecurityErrors* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 15);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* securityWrongSyncTime */
         case 0:
            /* NULL */

            break;

         /* securityReplay */
         case 1:
            /* NULL */

            break;

         /* securityWrongGeneralID */
         case 2:
            /* NULL */

            break;

         /* securityWrongSendersID */
         case 3:
            /* NULL */

            break;

         /* securityIntegrityFailed */
         case 4:
            /* NULL */

            break;

         /* securityWrongOID */
         case 5:
            /* NULL */

            break;

         /* securityDHmismatch */
         case 6:
            /* NULL */

            break;

         /* securityCertificateExpired */
         case 7:
            /* NULL */

            break;

         /* securityCertificateDateInvalid */
         case 8:
            /* NULL */

            break;

         /* securityCertificateRevoked */
         case 9:
            /* NULL */

            break;

         /* securityCertificateNotReadable */
         case 10:
            /* NULL */

            break;

         /* securityCertificateSignatureInvalid */
         case 11:
            /* NULL */

            break;

         /* securityCertificateMissing */
         case 12:
            /* NULL */

            break;

         /* securityCertificateIncomplete */
         case 13:
            /* NULL */

            break;

         /* securityUnsupportedCertificateAlgOID */
         case 14:
            /* NULL */

            break;

         /* securityUnknownCA */
         case 15:
            /* NULL */

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 17;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReleaseCompleteReason                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225ReleaseCompleteReason (OOCTXT* pctxt, H225ReleaseCompleteReason* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 11);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* noBandwidth */
         case 0:
            /* NULL */

            break;

         /* gatekeeperResources */
         case 1:
            /* NULL */

            break;

         /* unreachableDestination */
         case 2:
            /* NULL */

            break;

         /* destinationRejection */
         case 3:
            /* NULL */

            break;

         /* invalidRevision */
         case 4:
            /* NULL */

            break;

         /* noPermission */
         case 5:
            /* NULL */

            break;

         /* unreachableGatekeeper */
         case 6:
            /* NULL */

            break;

         /* gatewayResources */
         case 7:
            /* NULL */

            break;

         /* badFormatAddress */
         case 8:
            /* NULL */

            break;

         /* adaptiveBusy */
         case 9:
            /* NULL */

            break;

         /* inConf */
         case 10:
            /* NULL */

            break;

         /* undefinedReason */
         case 11:
            /* NULL */

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 13;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* facilityCallDeflection */
         case 13:
            /* NULL */

            break;

         /* securityDenied */
         case 14:
            /* NULL */

            break;

         /* calledPartyNotRegistered */
         case 15:
            /* NULL */

            break;

         /* callerNotRegistered */
         case 16:
            /* NULL */

            break;

         /* newConnectionNeeded */
         case 17:
            /* NULL */

            break;

         /* nonStandardReason */
         case 18:
            pvalue->u.nonStandardReason = ALLOC_ASN1ELEM (pctxt, H225NonStandardParameter);
            if (pvalue->u.nonStandardReason == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225NonStandardParameter (pctxt, pvalue->u.nonStandardReason);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* replaceWithConferenceInvite */
         case 19:
            pvalue->u.replaceWithConferenceInvite = ALLOC_ASN1ELEM (pctxt, H225ConferenceIdentifier);
            if (pvalue->u.replaceWithConferenceInvite == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225ConferenceIdentifier (pctxt, pvalue->u.replaceWithConferenceInvite);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* genericDataReason */
         case 20:
            /* NULL */

            break;

         /* neededFeatureNotSupported */
         case 21:
            /* NULL */

            break;

         /* tunnelledSignallingRejected */
         case 22:
            /* NULL */

            break;

         /* invalidCID */
         case 23:
            /* NULL */

            break;

         /* securityError */
         case 24:
            pvalue->u.securityError = ALLOC_ASN1ELEM (pctxt, H225SecurityErrors);
            if (pvalue->u.securityError == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225SecurityErrors (pctxt, pvalue->u.securityError);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* hopCountExceeded */
         case 25:
            /* NULL */

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReleaseComplete_UUIE                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225ReleaseComplete_UUIE (OOCTXT* pctxt, H225ReleaseComplete_UUIE* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.reasonPresent = optbit;

   /* decode protocolIdentifier */

   stat = asn1PD_H225ProtocolIdentifier (pctxt, &pvalue->protocolIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode reason */

   if (pvalue->m.reasonPresent) {
      stat = asn1PD_H225ReleaseCompleteReason (pctxt, &pvalue->reason);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 9 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.callIdentifierPresent = 1;

                     stat = asn1PD_H225CallIdentifier (pctxt, &pvalue->callIdentifier);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 1:
                     pvalue->m.tokensPresent = 1;

                     stat = asn1PD_H225_SeqOfH225ClearToken (pctxt, &pvalue->tokens);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 2:
                     pvalue->m.cryptoTokensPresent = 1;

                     stat = asn1PD_H225_SeqOfH225CryptoH323Token (pctxt, &pvalue->cryptoTokens);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 3:
                     pvalue->m.busyAddressPresent = 1;

                     stat = asn1PD_H225_SeqOfH225AliasAddress (pctxt, &pvalue->busyAddress);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 4:
                     pvalue->m.presentationIndicatorPresent = 1;

                     stat = asn1PD_H225PresentationIndicator (pctxt, &pvalue->presentationIndicator);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 5:
                     pvalue->m.screeningIndicatorPresent = 1;

                     stat = asn1PD_H225ScreeningIndicator (pctxt, &pvalue->screeningIndicator);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 6:
                     pvalue->m.capacityPresent = 1;

                     stat = asn1PD_H225CallCapacity (pctxt, &pvalue->capacity);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 7:
                     pvalue->m.serviceControlPresent = 1;

                     stat = asn1PD_H225_SeqOfH225ServiceControlSession (pctxt, &pvalue->serviceControl);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 8:
                     pvalue->m.featureSetPresent = 1;

                     stat = asn1PD_H225FeatureSet (pctxt, &pvalue->featureSet);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FacilityReason                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225FacilityReason (OOCTXT* pctxt, H225FacilityReason* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 3);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* routeCallToGatekeeper */
         case 0:
            /* NULL */

            break;

         /* callForwarded */
         case 1:
            /* NULL */

            break;

         /* routeCallToMC */
         case 2:
            /* NULL */

            break;

         /* undefinedReason */
         case 3:
            /* NULL */

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 5;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* conferenceListChoice */
         case 5:
            /* NULL */

            break;

         /* startH245 */
         case 6:
            /* NULL */

            break;

         /* noH245 */
         case 7:
            /* NULL */

            break;

         /* newTokens */
         case 8:
            /* NULL */

            break;

         /* featureSetUpdate */
         case 9:
            /* NULL */

            break;

         /* forwardedElements */
         case 10:
            /* NULL */

            break;

         /* transportedInformation */
         case 11:
            /* NULL */

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConferenceList                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225ConferenceList (OOCTXT* pctxt, H225ConferenceList* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.conferenceIDPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.conferenceAliasPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   /* decode conferenceID */

   if (pvalue->m.conferenceIDPresent) {
      stat = asn1PD_H225ConferenceIdentifier (pctxt, &pvalue->conferenceID);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode conferenceAlias */

   if (pvalue->m.conferenceAliasPresent) {
      stat = asn1PD_H225AliasAddress (pctxt, &pvalue->conferenceAlias);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH225ConferenceList                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225_SeqOfH225ConferenceList (OOCTXT* pctxt, H225_SeqOfH225ConferenceList* pvalue)
{
   int stat = ASN_OK;
   H225ConferenceList* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225ConferenceList);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H225ConferenceList (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Facility_UUIE_fastStart                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Facility_UUIE_fastStart (OOCTXT* pctxt, H225Facility_UUIE_fastStart* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, ASN1DynOctStr);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Facility_UUIE                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Facility_UUIE (OOCTXT* pctxt, H225Facility_UUIE* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.alternativeAddressPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.alternativeAliasAddressPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.conferenceIDPresent = optbit;

   /* decode protocolIdentifier */

   stat = asn1PD_H225ProtocolIdentifier (pctxt, &pvalue->protocolIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode alternativeAddress */

   if (pvalue->m.alternativeAddressPresent) {
      stat = asn1PD_H225TransportAddress (pctxt, &pvalue->alternativeAddress);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode alternativeAliasAddress */

   if (pvalue->m.alternativeAliasAddressPresent) {
      stat = asn1PD_H225_SeqOfH225AliasAddress (pctxt, &pvalue->alternativeAliasAddress);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode conferenceID */

   if (pvalue->m.conferenceIDPresent) {
      stat = asn1PD_H225ConferenceIdentifier (pctxt, &pvalue->conferenceID);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode reason */

   stat = asn1PD_H225FacilityReason (pctxt, &pvalue->reason);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 16 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.callIdentifierPresent = 1;

                     stat = asn1PD_H225CallIdentifier (pctxt, &pvalue->callIdentifier);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 1:
                     pvalue->m.destExtraCallInfoPresent = 1;

                     stat = asn1PD_H225_SeqOfH225AliasAddress (pctxt, &pvalue->destExtraCallInfo);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 2:
                     pvalue->m.remoteExtensionAddressPresent = 1;

                     stat = asn1PD_H225AliasAddress (pctxt, &pvalue->remoteExtensionAddress);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 3:
                     pvalue->m.tokensPresent = 1;

                     stat = asn1PD_H225_SeqOfH225ClearToken (pctxt, &pvalue->tokens);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 4:
                     pvalue->m.cryptoTokensPresent = 1;

                     stat = asn1PD_H225_SeqOfH225CryptoH323Token (pctxt, &pvalue->cryptoTokens);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 5:
                     pvalue->m.conferencesPresent = 1;

                     stat = asn1PD_H225_SeqOfH225ConferenceList (pctxt, &pvalue->conferences);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 6:
                     pvalue->m.h245AddressPresent = 1;

                     stat = asn1PD_H225TransportAddress (pctxt, &pvalue->h245Address);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 7:
                     pvalue->m.fastStartPresent = 1;

                     stat = asn1PD_H225Facility_UUIE_fastStart (pctxt, &pvalue->fastStart);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 8:
                     pvalue->m.multipleCallsPresent = 1;

                     stat = DECODEBIT (pctxt, &pvalue->multipleCalls);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 9:
                     pvalue->m.maintainConnectionPresent = 1;

                     stat = DECODEBIT (pctxt, &pvalue->maintainConnection);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 10:
                     pvalue->m.fastConnectRefusedPresent = 1;

                     /* NULL */
                     break;

                  case 11:
                     pvalue->m.serviceControlPresent = 1;

                     stat = asn1PD_H225_SeqOfH225ServiceControlSession (pctxt, &pvalue->serviceControl);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 12:
                     pvalue->m.circuitInfoPresent = 1;

                     stat = asn1PD_H225CircuitInfo (pctxt, &pvalue->circuitInfo);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 13:
                     pvalue->m.featureSetPresent = 1;

                     stat = asn1PD_H225FeatureSet (pctxt, &pvalue->featureSet);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 14:
                     pvalue->m.destinationInfoPresent = 1;

                     stat = asn1PD_H225EndpointType (pctxt, &pvalue->destinationInfo);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 15:
                     pvalue->m.h245SecurityModePresent = 1;

                     stat = asn1PD_H225H245Security (pctxt, &pvalue->h245SecurityMode);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Progress_UUIE_fastStart                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Progress_UUIE_fastStart (OOCTXT* pctxt, H225Progress_UUIE_fastStart* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, ASN1DynOctStr);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Progress_UUIE                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Progress_UUIE (OOCTXT* pctxt, H225Progress_UUIE* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.h245AddressPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.h245SecurityModePresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tokensPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cryptoTokensPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.fastStartPresent = optbit;

   /* decode protocolIdentifier */

   stat = asn1PD_H225ProtocolIdentifier (pctxt, &pvalue->protocolIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode destinationInfo */

   stat = asn1PD_H225EndpointType (pctxt, &pvalue->destinationInfo);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode h245Address */

   if (pvalue->m.h245AddressPresent) {
      stat = asn1PD_H225TransportAddress (pctxt, &pvalue->h245Address);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode callIdentifier */

   stat = asn1PD_H225CallIdentifier (pctxt, &pvalue->callIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode h245SecurityMode */

   if (pvalue->m.h245SecurityModePresent) {
      stat = asn1PD_H225H245Security (pctxt, &pvalue->h245SecurityMode);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode tokens */

   if (pvalue->m.tokensPresent) {
      stat = asn1PD_H225_SeqOfH225ClearToken (pctxt, &pvalue->tokens);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode cryptoTokens */

   if (pvalue->m.cryptoTokensPresent) {
      stat = asn1PD_H225_SeqOfH225CryptoH323Token (pctxt, &pvalue->cryptoTokens);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode fastStart */

   if (pvalue->m.fastStartPresent) {
      stat = asn1PD_H225Progress_UUIE_fastStart (pctxt, &pvalue->fastStart);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 3 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.multipleCallsPresent = 1;

                     stat = DECODEBIT (pctxt, &pvalue->multipleCalls);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 1:
                     pvalue->m.maintainConnectionPresent = 1;

                     stat = DECODEBIT (pctxt, &pvalue->maintainConnection);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 2:
                     pvalue->m.fastConnectRefusedPresent = 1;

                     /* NULL */
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Status_UUIE                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Status_UUIE (OOCTXT* pctxt, H225Status_UUIE* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tokensPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cryptoTokensPresent = optbit;

   /* decode protocolIdentifier */

   stat = asn1PD_H225ProtocolIdentifier (pctxt, &pvalue->protocolIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode callIdentifier */

   stat = asn1PD_H225CallIdentifier (pctxt, &pvalue->callIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode tokens */

   if (pvalue->m.tokensPresent) {
      stat = asn1PD_H225_SeqOfH225ClearToken (pctxt, &pvalue->tokens);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode cryptoTokens */

   if (pvalue->m.cryptoTokensPresent) {
      stat = asn1PD_H225_SeqOfH225CryptoH323Token (pctxt, &pvalue->cryptoTokens);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StatusInquiry_UUIE                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225StatusInquiry_UUIE (OOCTXT* pctxt, H225StatusInquiry_UUIE* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tokensPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cryptoTokensPresent = optbit;

   /* decode protocolIdentifier */

   stat = asn1PD_H225ProtocolIdentifier (pctxt, &pvalue->protocolIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode callIdentifier */

   stat = asn1PD_H225CallIdentifier (pctxt, &pvalue->callIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode tokens */

   if (pvalue->m.tokensPresent) {
      stat = asn1PD_H225_SeqOfH225ClearToken (pctxt, &pvalue->tokens);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode cryptoTokens */

   if (pvalue->m.cryptoTokensPresent) {
      stat = asn1PD_H225_SeqOfH225CryptoH323Token (pctxt, &pvalue->cryptoTokens);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SetupAcknowledge_UUIE                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225SetupAcknowledge_UUIE (OOCTXT* pctxt, H225SetupAcknowledge_UUIE* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tokensPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cryptoTokensPresent = optbit;

   /* decode protocolIdentifier */

   stat = asn1PD_H225ProtocolIdentifier (pctxt, &pvalue->protocolIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode callIdentifier */

   stat = asn1PD_H225CallIdentifier (pctxt, &pvalue->callIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode tokens */

   if (pvalue->m.tokensPresent) {
      stat = asn1PD_H225_SeqOfH225ClearToken (pctxt, &pvalue->tokens);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode cryptoTokens */

   if (pvalue->m.cryptoTokensPresent) {
      stat = asn1PD_H225_SeqOfH225CryptoH323Token (pctxt, &pvalue->cryptoTokens);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Notify_UUIE                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225Notify_UUIE (OOCTXT* pctxt, H225Notify_UUIE* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tokensPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.cryptoTokensPresent = optbit;

   /* decode protocolIdentifier */

   stat = asn1PD_H225ProtocolIdentifier (pctxt, &pvalue->protocolIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode callIdentifier */

   stat = asn1PD_H225CallIdentifier (pctxt, &pvalue->callIdentifier);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode tokens */

   if (pvalue->m.tokensPresent) {
      stat = asn1PD_H225_SeqOfH225ClearToken (pctxt, &pvalue->tokens);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode cryptoTokens */

   if (pvalue->m.cryptoTokensPresent) {
      stat = asn1PD_H225_SeqOfH225CryptoH323Token (pctxt, &pvalue->cryptoTokens);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H323_UU_PDU_h323_message_body                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225H323_UU_PDU_h323_message_body (OOCTXT* pctxt, H225H323_UU_PDU_h323_message_body* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;
   ASN1OpenType openType;
   ASN1BOOL extbit;
   OOCTXT lctxt;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (!extbit) {
      stat = decodeConsUnsigned (pctxt, &ui, 0, 6);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* setup */
         case 0:
            pvalue->u.setup = ALLOC_ASN1ELEM (pctxt, H225Setup_UUIE);
            if (pvalue->u.setup == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225Setup_UUIE (pctxt, pvalue->u.setup);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* callProceeding */
         case 1:
            pvalue->u.callProceeding = ALLOC_ASN1ELEM (pctxt, H225CallProceeding_UUIE);
            if (pvalue->u.callProceeding == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225CallProceeding_UUIE (pctxt, pvalue->u.callProceeding);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* connect */
         case 2:
            pvalue->u.connect = ALLOC_ASN1ELEM (pctxt, H225Connect_UUIE);
            if (pvalue->u.connect == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225Connect_UUIE (pctxt, pvalue->u.connect);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* alerting */
         case 3:
            pvalue->u.alerting = ALLOC_ASN1ELEM (pctxt, H225Alerting_UUIE);
            if (pvalue->u.alerting == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225Alerting_UUIE (pctxt, pvalue->u.alerting);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* information */
         case 4:
            pvalue->u.information = ALLOC_ASN1ELEM (pctxt, H225Information_UUIE);
            if (pvalue->u.information == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225Information_UUIE (pctxt, pvalue->u.information);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* releaseComplete */
         case 5:
            pvalue->u.releaseComplete = ALLOC_ASN1ELEM (pctxt, H225ReleaseComplete_UUIE);
            if (pvalue->u.releaseComplete == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225ReleaseComplete_UUIE (pctxt, pvalue->u.releaseComplete);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* facility */
         case 6:
            pvalue->u.facility = ALLOC_ASN1ELEM (pctxt, H225Facility_UUIE);
            if (pvalue->u.facility == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225Facility_UUIE (pctxt, pvalue->u.facility);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:
            return LOG_ASN1ERR (pctxt, ASN_E_INVOPT);
      }
   }
   else {
      stat = decodeSmallNonNegWholeNumber (pctxt, &ui);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
      else pvalue->t = ui + 8;

      stat = decodeByteAlign (pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      copyContext (&lctxt, pctxt);
      initContextBuffer (pctxt, openType.data, openType.numocts);

      switch (pvalue->t) {
         /* progress */
         case 8:
            pvalue->u.progress = ALLOC_ASN1ELEM (pctxt, H225Progress_UUIE);
            if (pvalue->u.progress == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225Progress_UUIE (pctxt, pvalue->u.progress);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
            break;
         /* empty */
         case 9:
            /* NULL */

            break;

         /* status */
         case 10:
            pvalue->u.status = ALLOC_ASN1ELEM (pctxt, H225Status_UUIE);
            if (pvalue->u.status == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225Status_UUIE (pctxt, pvalue->u.status);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* statusInquiry */
         case 11:
            pvalue->u.statusInquiry = ALLOC_ASN1ELEM (pctxt, H225StatusInquiry_UUIE);
            if (pvalue->u.statusInquiry == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225StatusInquiry_UUIE (pctxt, pvalue->u.statusInquiry);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* setupAcknowledge */
         case 12:
            pvalue->u.setupAcknowledge = ALLOC_ASN1ELEM (pctxt, H225SetupAcknowledge_UUIE);
            if (pvalue->u.setupAcknowledge == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225SetupAcknowledge_UUIE (pctxt, pvalue->u.setupAcknowledge);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         /* notify */
         case 13:
            pvalue->u.notify = ALLOC_ASN1ELEM (pctxt, H225Notify_UUIE);
            if (pvalue->u.notify == NULL)
               return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

            stat = asn1PD_H225Notify_UUIE (pctxt, pvalue->u.notify);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            break;

         default:;
      }

      copyContext (pctxt, &lctxt);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H323_UU_PDU_h4501SupplementaryService                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225H323_UU_PDU_h4501SupplementaryService (OOCTXT* pctxt, H225H323_UU_PDU_h4501SupplementaryService* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, ASN1DynOctStr);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H323_UU_PDU_h245Control                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225H323_UU_PDU_h245Control (OOCTXT* pctxt, H225H323_UU_PDU_h245Control* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, ASN1DynOctStr);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfH225NonStandardParameter                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225_SeqOfH225NonStandardParameter (OOCTXT* pctxt, H225_SeqOfH225NonStandardParameter* pvalue)
{
   int stat = ASN_OK;
   H225NonStandardParameter* pdata;
   ASN1UINT count = 0;
   ASN1UINT xx1;
   int lstat;

   dListInit (pvalue);

   for (;;) {
      /* decode length determinant */

      lstat = decodeLength (pctxt, &count);
      if (lstat != ASN_OK && lstat != ASN_OK_FRAG) {
         return LOG_ASN1ERR (pctxt, lstat);
      }

      /* decode elements */

      for (xx1 = 0; xx1 < count; xx1++) {
         pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225NonStandardParameter);
         if (pdata == NULL)
            return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

         stat = asn1PD_H225NonStandardParameter (pctxt, pdata);
         if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
         dListAppendNode (pctxt, pvalue, pdata);
      }

      if(lstat == ASN_OK) break;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CallLinkage                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225CallLinkage (OOCTXT* pctxt, H225CallLinkage* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.globalCallIdPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.threadIdPresent = optbit;

   /* decode globalCallId */

   if (pvalue->m.globalCallIdPresent) {
      stat = asn1PD_H225GloballyUniqueID (pctxt, &pvalue->globalCallId);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode threadId */

   if (pvalue->m.threadIdPresent) {
      stat = asn1PD_H225GloballyUniqueID (pctxt, &pvalue->threadId);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H323_UU_PDU_tunnelledSignallingMessage_messageContent     */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225H323_UU_PDU_tunnelledSignallingMessage_messageContent (OOCTXT* pctxt, H225H323_UU_PDU_tunnelledSignallingMessage_messageContent* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = decodeLength (pctxt, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode elements */

   ALLOC_ASN1ARRAY (pctxt, pvalue, ASN1DynOctStr);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H323_UU_PDU_tunnelledSignallingMessage                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225H323_UU_PDU_tunnelledSignallingMessage (OOCTXT* pctxt, H225H323_UU_PDU_tunnelledSignallingMessage* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.tunnellingRequiredPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   /* decode tunnelledProtocolID */

   stat = asn1PD_H225TunnelledProtocol (pctxt, &pvalue->tunnelledProtocolID);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode messageContent */

   stat = asn1PD_H225H323_UU_PDU_tunnelledSignallingMessage_messageContent (pctxt, &pvalue->messageContent);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode tunnellingRequired */

   if (pvalue->m.tunnellingRequiredPresent) {
      /* NULL */
   }

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StimulusControl                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225StimulusControl (OOCTXT* pctxt, H225StimulusControl* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.isTextPresent = optbit;

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.h248MessagePresent = optbit;

   /* decode nonStandard */

   if (pvalue->m.nonStandardPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandard);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   /* decode isText */

   if (pvalue->m.isTextPresent) {
      /* NULL */
   }

   /* decode h248Message */

   if (pvalue->m.h248MessagePresent) {
      stat = decodeDynOctetString (pctxt, (ASN1DynOctStr*)&pvalue->h248Message);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H323_UU_PDU                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225H323_UU_PDU (OOCTXT* pctxt, H225H323_UU_PDU* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   OOCTXT lctxt2;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.nonStandardDataPresent = optbit;

   /* decode h323_message_body */

   stat = asn1PD_H225H323_UU_PDU_h323_message_body (pctxt, &pvalue->h323_message_body);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode nonStandardData */

   if (pvalue->m.nonStandardDataPresent) {
      stat = asn1PD_H225NonStandardParameter (pctxt, &pvalue->nonStandardData);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            if (i < 9 && openType.numocts > 0) {  /* known element */
               copyContext (&lctxt2, pctxt);
               initContextBuffer (pctxt, openType.data, openType.numocts);

               switch (i) {
                  case 0:
                     pvalue->m.h4501SupplementaryServicePresent = 1;

                     stat = asn1PD_H225H323_UU_PDU_h4501SupplementaryService (pctxt, &pvalue->h4501SupplementaryService);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 1:
                     pvalue->m.h245TunnelingPresent = 1;

                     stat = DECODEBIT (pctxt, &pvalue->h245Tunneling);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 2:
                     pvalue->m.h245ControlPresent = 1;

                     stat = asn1PD_H225H323_UU_PDU_h245Control (pctxt, &pvalue->h245Control);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 3:
                     pvalue->m.nonStandardControlPresent = 1;

                     stat = asn1PD_H225_SeqOfH225NonStandardParameter (pctxt, &pvalue->nonStandardControl);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 4:
                     pvalue->m.callLinkagePresent = 1;

                     stat = asn1PD_H225CallLinkage (pctxt, &pvalue->callLinkage);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 5:
                     pvalue->m.tunnelledSignallingMessagePresent = 1;

                     stat = asn1PD_H225H323_UU_PDU_tunnelledSignallingMessage (pctxt, &pvalue->tunnelledSignallingMessage);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 6:
                     pvalue->m.provisionalRespToH245TunnelingPresent = 1;

                     /* NULL */
                     break;

                  case 7:
                     pvalue->m.stimulusControlPresent = 1;

                     stat = asn1PD_H225StimulusControl (pctxt, &pvalue->stimulusControl);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  case 8:
                     pvalue->m.genericDataPresent = 1;

                     stat = asn1PD_H225_SeqOfH225GenericData (pctxt, &pvalue->genericData);
                     if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
                     break;

                  default:
                     pctxt->buffer.byteIndex += openType.numocts;
               }
               copyContext (pctxt, &lctxt2);
            }
            else {  /* unknown element */
               pctxt->buffer.byteIndex += openType.numocts;
            }
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H323_UserInformation_user_data_user_information           */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225H323_UserInformation_user_data_user_information (OOCTXT* pctxt, H225H323_UserInformation_user_data_user_information* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, 1, 131, 0 };
   int stat = ASN_OK;

   stat = addSizeConstraint (pctxt, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   stat = decodeOctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H323_UserInformation_user_data                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225H323_UserInformation_user_data (OOCTXT* pctxt, H225H323_UserInformation_user_data* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode protocol_discriminator */

   stat = decodeConsUInt8 (pctxt, &pvalue->protocol_discriminator, 0U, 255U);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode user_information */

   stat = asn1PD_H225H323_UserInformation_user_data_user_information (pctxt, &pvalue->user_information);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  H323_UserInformation                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1PD_H225H323_UserInformation (OOCTXT* pctxt, H225H323_UserInformation* pvalue)
{
   int stat = ASN_OK;
   OOCTXT lctxt;
   ASN1OpenType openType;
   ASN1UINT bitcnt;
   ASN1UINT i;
   ASN1BOOL optbit;
   ASN1BOOL extbit;

   /* extension bit */

   stat = DECODEBIT (pctxt, &extbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = DECODEBIT (pctxt, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   else pvalue->m.user_dataPresent = optbit;

   /* decode h323_uu_pdu */

   stat = asn1PD_H225H323_UU_PDU (pctxt, &pvalue->h323_uu_pdu);
   if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

   /* decode user_data */

   if (pvalue->m.user_dataPresent) {
      stat = asn1PD_H225H323_UserInformation_user_data (pctxt, &pvalue->user_data);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      bitcnt += 1;

      ZEROCONTEXT (&lctxt);
      stat = setPERBufferUsingCtxt (&lctxt, pctxt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      stat = moveBitCursor (pctxt, bitcnt);
      if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         DECODEBIT (&lctxt, &optbit);

         if (optbit) {
            stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

            pctxt->buffer.byteIndex += openType.numocts;
         }
      }
   }

   return (stat);
}


//added by tony below 12/08/2004
EXTERN int asn1PD_H225GatekeeperRequest(OOCTXT *pctxt,H225GatekeeperRequest *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225GatekeeperConfirm(OOCTXT *pctxt,H225GatekeeperConfirm *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225GatekeeperReject(OOCTXT *pctxt,H225GatekeeperReject *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225RegistrationRequest (OOCTXT* pctxt, H225RegistrationRequest* pvalue)
{
	int stat = ASN_OK;
	
	
	return stat;
}

EXTERN int asn1PD_H225_SeqOfH225TransportAddress(OOCTXT* pctxt,H225_SeqOfH225TransportAddress* pvalue)
{
	int stat = ASN_OK;
	H225TransportAddress *pdata;
	ASN1UINT count = 0;
	ASN1UINT i;
	int lstat;

	dListInit(pvalue);
	for(;;)
	{
		lstat = decodeLength(pctxt,&count);
		if(lstat != ASN_OK && lstat != ASN_OK_FRAG)
			return LOG_ASN1ERR(pctxt,lstat);

		/*decode elements*/
		for(i = 0; i < count; i++)
		{
			pdata = ALLOC_ASN1ELEMDNODE(pctxt,H225TransportAddress);
			if(pdata == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);

			stat = asn1PD_H225TransportAddress(pctxt,pdata);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			dListAppendNode(pctxt,pvalue,pdata);
		}

		if(lstat == ASN_OK) break;
	}

	return stat;	
}

EXTERN int asn1PD_H225AlternateGK(OOCTXT *pctxt,H225AlternateGK *pvalue)
{
	int stat = ASN_OK;
	ASN1BOOL extbit,optbit;
	
	stat = DECODEBIT(pctxt,&extbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	memset(&pvalue->m,0,sizeof(pvalue->m));
	
	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.gatekeeperIdentifierPresent = optbit;
	
	stat = asn1PD_H225TransportAddress(pctxt,&pvalue->rasAddress);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	if(pvalue->m.gatekeeperIdentifierPresent)
	{
		stat = asn1PD_H225GatekeeperIdentifier(pctxt,&pvalue->gatekeeperIdentifier);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}	
	
	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->needToRegister = optbit;

	stat = decodeConsUInt8(pctxt,&pvalue->priority,0U,127U);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	return stat;
}

EXTERN int asn1PD_H225_SeqOfH225AlternateGK(OOCTXT *pctxt,H225_SeqOfH225AlternateGK * pvalue)
{
	int stat = ASN_OK;
	H225AlternateGK *pdata;
	ASN1UINT count = 0;
	ASN1UINT i;
	int lstat;

	dListInit(pvalue);
	for(;;)
	{
		lstat = decodeLength(pctxt,&count);
		if(lstat != ASN_OK && lstat != ASN_OK_FRAG)
			return LOG_ASN1ERR(pctxt,lstat);

		/*decode elements*/
		for(i = 0; i < count; i++)
		{
			pdata = ALLOC_ASN1ELEMDNODE(pctxt,H225AlternateGK);
			if(pdata == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);

			stat = asn1PD_H225AlternateGK(pctxt,pdata);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			dListAppendNode(pctxt,pvalue,pdata);
		}

		if(lstat == ASN_OK) break;
	}

	return stat;
}

EXTERN int asn1PD_H225ICV(OOCTXT* pctxt,H225ICV *pvalue)
{
	int stat = ASN_OK;
	
	stat = decodeObjectIdentifier(pctxt,&pvalue->algorithmOID);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	//decode icv

	return stat;
}

EXTERN int asn1PD_H225UseSpecifiedTransport(OOCTXT *pctxt,H225UseSpecifiedTransport *pvalue)
{
	int stat = ASN_OK;
	ASN1UINT ui;
	ASN1OpenType openType;
	ASN1BOOL extbit;
	OOCTXT lctxt;

	stat = DECODEBIT(pctxt,&extbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	if(!extbit)
	{
		stat = decodeConsUnsigned(pctxt,&ui,0,1);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
		else pvalue->t = ui + 1;
		switch(pvalue->t)
		{
		case T_H225UseSpecifiedTransport_tcp:
			//NULL
			break;
		case T_H225UseSpecifiedTransport_annexE:
			//NULL
			break;
		default:
			return LOG_ASN1ERR(pctxt,ASN_E_INVOPT);
		}
	}
	else
	{
		stat = decodeSmallNonNegWholeNumber(pctxt,&ui);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
		else pvalue->t = ui + 3;

		stat = decodeByteAlign(pctxt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

		stat = decodeOpenType(pctxt,&openType.data,&openType.numocts);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

		copyContext(&lctxt,pctxt);
		initContextBuffer(pctxt,openType.data,openType.numocts);

		switch(pvalue->t)
		{
		case T_H225UseSpecifiedTransport_sctp:
			//NULL
			break;
		default:;
		}
		copyContext(pctxt,&lctxt);
	}

	return stat;
}

EXTERN int asn1PD_H225AlternateTransportAddresses(OOCTXT *pctxt,H225AlternateTransportAddresses *pvalue)
{
	int stat = ASN_OK;
	ASN1BOOL extbit,optbit;
	ASN1UINT bitcnt,i;
	OOCTXT lctxt,lctxt2;
	ASN1OpenType openType;

	stat = DECODEBIT(pctxt,&extbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	memset(&pvalue->m,0,sizeof(pvalue->m));

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.annexEPresent = optbit;

	if(pvalue->m.annexEPresent)
	{
		stat = asn1PD_H225_SeqOfH225TransportAddress(pctxt,&pvalue->annexE);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(extbit)
	{
		stat = decodeSmallNonNegWholeNumber(pctxt,&bitcnt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
		bitcnt += 1;

		ZEROCONTEXT(&lctxt);
		stat = setPERBufferUsingCtxt(&lctxt,pctxt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
		
		stat = moveBitCursor(pctxt,bitcnt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

		for(i = 0; i < bitcnt; i++)
		{
			DECODEBIT(&lctxt,&optbit);
			if(optbit)
			{
				stat = decodeOpenType(pctxt,&openType.data,&openType.numocts);
				if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
				
				if(i < 1 && openType.numocts > 0)
				{
					copyContext(&lctxt2,pctxt);
					initContextBuffer(pctxt,openType.data,openType.numocts);
					switch(i)
					{
					case 0:
						pvalue->m.sctpPresent = 1;
						stat = asn1PD_H225_SeqOfH225TransportAddress(pctxt,&pvalue->sctp);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					default:
						pctxt->buffer.byteIndex += openType.numocts;
					}
					copyContext(pctxt,&lctxt2);
				}
				else //unknow element
					pctxt->buffer.byteIndex += openType.numocts;
			}
		}
	}

	return stat;
}

EXTERN int asn1PD_H225RegistrationConfirm_preGrantedARQ(OOCTXT *pctxt,H225RegistrationConfirm_preGrantedARQ *pvalue)
{
	int stat = ASN_OK;
	ASN1BOOL extbit,optbit;
	ASN1UINT i,bitcnt;
	OOCTXT lctxt,lctxt2;
	ASN1OpenType openType;

	stat = DECODEBIT(pctxt,&extbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	memset(&pvalue->m,0,sizeof(pvalue->m));
	
	stat = DECODEBIT(pctxt,&pvalue->makeCall);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	stat = DECODEBIT(pctxt,&pvalue->useGKCallSignalAddressToMakeCall);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	stat = DECODEBIT(pctxt,&pvalue->answerCall);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	
	stat = DECODEBIT(pctxt,&pvalue->useGKCallSignalAddressToAnswer);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	
	if(extbit)
	{
		/*decode extension optional bits length*/
		stat = decodeSmallNonNegWholeNumber(pctxt,&bitcnt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
		bitcnt += 1;
		ZEROCONTEXT(&lctxt);
		stat = setPERBufferUsingCtxt(&lctxt,pctxt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

		for(i = 0; i < bitcnt; i++)
		{
			DECODEBIT(&lctxt,&optbit);
			if(optbit)
			{
				stat = decodeOpenType(pctxt,&openType.data,&openType.numocts);
				if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
				if(i < 4 && openType.numocts > 0) //known element
				{
					copyContext(&lctxt2,pctxt);
					initContextBuffer(pctxt,openType.data,openType.numocts);

					switch(i)
					{
					case 0:
						pvalue->m.irrFrequencyInCallPresent = 1;
						stat = decodeConsUInt16(pctxt,&pvalue->irrFrequencyInCall,1U,65535U);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 1:
						pvalue->m.totalBandwidthRestrictionPresent = 1;
						stat = asn1PD_H225BandWidth(pctxt,&pvalue->totalBandwidthRestriction);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 2:
						pvalue->m.alternateTransportAddressesPresent = 1;
						stat = asn1PD_H225AlternateTransportAddresses(pctxt,&pvalue->alternateTransportAddresses);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 3:
						pvalue->m.useSpecifiedTransportPresent = 1;
						stat = asn1PD_H225UseSpecifiedTransport(pctxt,&pvalue->useSpecifiedTransport);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					default:
						pctxt->buffer.byteIndex += openType.numocts;
					}
					copyContext(pctxt,&lctxt2);
				}
				else	//unkown element
					pctxt->buffer.byteIndex += openType.numocts;
			}
		}
	}

	return stat;
}

EXTERN int asn1PD_H225AddressPattern_range(OOCTXT *pctxt,H225AddressPattern_range *pvalue)
{
	int stat = ASN_OK;
	
	stat = asn1PD_H225PartyNumber(pctxt,&pvalue->startOfRange);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	stat = asn1PD_H225PartyNumber(pctxt,&pvalue->endOfRange);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	return stat;
}

EXTERN int asn1PD_H225AddressPattern(OOCTXT *pctxt,H225AddressPattern *pvalue)
{
	int stat = ASN_OK;
	ASN1UINT ui;
	ASN1BOOL extbit;

	stat = DECODEBIT(pctxt,&extbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	if(!extbit)
	{
		stat = decodeConsUnsigned(pctxt,&ui,0,1);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
		else pvalue->t = ui + 1;

		switch(pvalue->t)
		{
		case T_H225AddressPattern_wildcard:
			pvalue->u.wildcard = ALLOC_ASN1ELEM(pctxt,H225AliasAddress);
			if(pvalue->u.wildcard)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225AliasAddress(pctxt,pvalue->u.wildcard);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225AddressPattern_range:
			pvalue->u.range = ALLOC_ASN1ELEM(pctxt,H225AddressPattern_range);
			if(pvalue->u.range)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225AddressPattern_range(pctxt,pvalue->u.range);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		default:
			return LOG_ASN1ERR(pctxt,ASN_E_INVOPT);
		}
	}
	else
	{
		stat = decodeSmallNonNegWholeNumber(pctxt,&ui);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
		else pvalue->t = ui + 3;

		stat = decodeByteAlign(pctxt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	return stat;
}

EXTERN int asn1PD_H225_SeqOfH225AddressPattern(OOCTXT *pctxt,H225_SeqOfH225AddressPattern * pvalue)
{
	int stat = ASN_OK;
	H225AddressPattern *pdata;
	ASN1UINT count = 0;
	ASN1UINT i;
	int lstat;

	dListInit(pvalue);
	for(;;)
	{
		lstat = decodeLength(pctxt,&count);
		if(lstat != ASN_OK && lstat != ASN_OK_FRAG)
			return LOG_ASN1ERR(pctxt,lstat);

		/*decode elements*/
		for(i = 0; i < count; i++)
		{
			pdata = ALLOC_ASN1ELEMDNODE(pctxt,H225AddressPattern);
			if(pdata == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);

			stat = asn1PD_H225AddressPattern(pctxt,pdata);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			dListAppendNode(pctxt,pvalue,pdata);
		}

		if(lstat == ASN_OK) break;
	}

	return stat;	
}

EXTERN int asn1PD_H225RasUsageSpecification(OOCTXT* pctxt,H225RasUsageSpecification *pvalue)
{
	int stat = ASN_OK;
	

	return stat;
}

EXTERN int asn1PD_H225_SeqOfH225RasUsageSpecification(OOCTXT *pctxt,H225_SeqOfH225RasUsageSpecification *pvalue)
{
	int stat = ASN_OK;
	H225RasUsageSpecification *pdata;
	ASN1UINT count = 0;
	ASN1UINT i;
	int lstat;

	dListInit(pvalue);
	for(;;)
	{
		lstat = decodeLength(pctxt,&count);
		if(lstat != ASN_OK && lstat != ASN_OK_FRAG)
			return LOG_ASN1ERR(pctxt,lstat);

		/*decode elements*/
		for(i = 0; i < count; i++)
		{
			pdata = ALLOC_ASN1ELEMDNODE(pctxt,H225RasUsageSpecification);
			if(pdata == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);

			stat = asn1PD_H225RasUsageSpecification(pctxt,pdata);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			dListAppendNode(pctxt,pvalue,pdata);
		}

		if(lstat == ASN_OK) break;
	}

	return stat;		
}

EXTERN int asn1PD_H225CapacityReportingSpecification(OOCTXT *pctxt,H225CapacityReportingSpecification *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225RegistrationConfirm(OOCTXT *pctxt,H225RegistrationConfirm* pvalue)
{
	int stat = ASN_OK;
	OOCTXT lctxt,lctxt2;
	ASN1OpenType openType;
	ASN1UINT i,bitcnt;
	ASN1BOOL optbit;
	ASN1BOOL extbit;

	stat = DECODEBIT(pctxt,&extbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	memset(&pvalue->m,0,sizeof(pvalue->m));
	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.nonStandardDataPresent = optbit;
	
	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.terminalAliasPresent = optbit;

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.gatekeeperIdentifierPresent = optbit;

	stat = decodeConsUInt16(pctxt,&pvalue->requestSeqNum,1U,65535U);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	stat = asn1PD_H225ProtocolIdentifier(pctxt,&pvalue->protocolIdentifier);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	if(pvalue->m.nonStandardDataPresent)
	{
		stat = asn1PD_H225NonStandardParameter(pctxt,&pvalue->nonStandardData);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	stat = asn1PD_H225_SeqOfH225TransportAddress(pctxt,&pvalue->callSignalAddress);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	if(pvalue->m.terminalAliasPresent)
	{
		stat = asn1PD_H225_SeqOfH225AliasAddress(pctxt,&pvalue->terminalAlias);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(pvalue->m.gatekeeperIdentifierPresent)
	{
		stat = asn1PD_H225GatekeeperIdentifier(pctxt,&pvalue->gatekeeperIdentifier);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	stat = asn1PD_H225EndpointIdentifier(pctxt,&pvalue->endpointIdentifier);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	
	if(extbit)
	{
		/*decode extension optional bits length*/
		stat = decodeSmallNonNegWholeNumber(pctxt,&bitcnt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
		bitcnt += 1;

		ZEROCONTEXT(&lctxt);
		stat = setPERBufferUsingCtxt(&lctxt,pctxt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

		stat = moveBitCursor(pctxt,bitcnt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

		for(i = 0; i < bitcnt; i++)
		{
			DECODEBIT(&lctxt,&optbit);
			if(optbit)
			{
				stat = decodeOpenType(pctxt,&openType.data,&openType.numocts);
				if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
				
				if(i < 17 && openType.numocts > 0)	//known element
				{
					copyContext(&lctxt2,pctxt);
					initContextBuffer(pctxt,openType.data,openType.numocts);
					switch(i)
					{
					case 0:
						pvalue->m.alternateGatekeeperPresent = 1;
						stat = asn1PD_H225_SeqOfH225AlternateGK(pctxt,&pvalue->alternateGatekeeper);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 1:
						pvalue->m.timeToLivePresent = 1;
						stat = decodeConsUnsigned(pctxt,&pvalue->timeToLive,1,ASN1UINT_MAX);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 2:
						pvalue->m.tokensPresent = 1;
						stat = asn1PD_H225_SeqOfH225ClearToken(pctxt,&pvalue->tokens);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 3:
						pvalue->m.cryptoTokensPresent = 1;
						stat = asn1PD_H225_SeqOfH225CryptoH323Token(pctxt,&pvalue->cryptoTokens);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 4:
						pvalue->m.integrityCheckValuePresent = 1;
						stat = asn1PD_H225ICV(pctxt,&pvalue->integrityCheckValue);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 5:
						pvalue->m.willRespondToIRRPresent = 1;
						stat = DECODEBIT(pctxt,&(pvalue->willRespondToIRR));
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 6:
						pvalue->m.preGrantedARQPresent = 1;
						stat = asn1PD_H225RegistrationConfirm_preGrantedARQ(pctxt,&pvalue->preGrantedARQ);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 7:
						pvalue->m.maintainConnectionPresent = 1;
						stat = DECODEBIT(pctxt,&pvalue->maintainConnection);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 8:
						pvalue->m.serviceControlPresent = 1;
						stat = asn1PD_H225_SeqOfH225ServiceControlSession(pctxt,&pvalue->serviceControl);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 9:
						pvalue->m.supportsAdditiveRegistrationPresent = 1;
						//NULL
						break;
					case 10:
						pvalue->m.terminalAliasPatternPresent = 1;
						stat = asn1PD_H225_SeqOfH225AddressPattern(pctxt,&pvalue->terminalAliasPattern);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 11:
						pvalue->m.supportedPrefixesPresent = 1;
						stat = asn1PD_H225_SeqOfH225SupportedPrefix(pctxt,&pvalue->supportedPrefixes);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 12:
						pvalue->m.usageSpecPresent = 1;
						stat = asn1PD_H225_SeqOfH225RasUsageSpecification(pctxt,&pvalue->usageSpec);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 13:
						pvalue->m.featureServerAliasPresent = 1;
						stat = asn1PD_H225AliasAddress(pctxt,&pvalue->featureServerAlias);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 14:
						pvalue->m.capacityReportingSpecPresent = 1;
						stat = asn1PD_H225CapacityReportingSpecification(pctxt,&pvalue->capacityReportingSpec);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 15:
						pvalue->m.featureSetPresent = 1;
						stat = asn1PD_H225FeatureSet(pctxt,&pvalue->featureSet);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 16:
						pvalue->m.genericDataPresent = 1;
						stat = asn1PD_H225_SeqOfH225GenericData(pctxt,&pvalue->genericData);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					default:
						pctxt->buffer.byteIndex += openType.numocts;
					}
					copyContext(pctxt,&lctxt2);
				}
				else
					pctxt->buffer.byteIndex += openType.numocts;
			}
		}
	}

	return stat;
}

EXTERN int asn1PD_H225RegistrationReject(OOCTXT *pctxt,H225RegistrationReject *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225UnregistrationRequest(OOCTXT *pctxt,H225UnregistrationRequest *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225UnregistrationConfirm(OOCTXT *pctxt,H225UnregistrationConfirm *pvalue)\
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225UnregistrationReject(OOCTXT *pctxt,H225UnregistrationReject *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225AdmissionRequest(OOCTXT *pctxt,H225AdmissionRequest *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

//
EXTERN int asn1PD_H225CallModel(OOCTXT* pctxt,H225CallModel *pvalue)
{
	int stat = ASN_OK;
	ASN1UINT ui;
	ASN1OpenType openType;
	ASN1BOOL extbit;

	stat = DECODEBIT(pctxt,&extbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	if(!extbit)
	{
		stat = decodeConsUnsigned(pctxt,&ui,0,1);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
		else pvalue->t = ui + 1;
		switch(pvalue->t)
		{
		case T_H225CallModel_direct:
			//NULL
			break;
		case T_H225CallModel_gatekeeperRouted:
			//NULL
			break;
		default:
			return LOG_ASN1ERR(pctxt,ASN_E_INVOPT);
		}
	}
	else
	{
		stat = decodeSmallNonNegWholeNumber(pctxt,&ui);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
		else pvalue->t = ui + 3;

		stat = decodeByteAlign(pctxt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

		stat = decodeOpenType(pctxt,&openType.data,&openType.numocts);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	return stat;	
}

EXTERN int asn1PD_H225Endpoint(OOCTXT* pctxt,H225Endpoint *pvalue)
{
	int stat = ASN_OK;
	OOCTXT lctxt,lctxt2;
	ASN1OpenType openType;
	ASN1UINT i,bitcnt;
	ASN1BOOL optbit;
	ASN1BOOL extbit;
	
	stat = DECODEBIT(pctxt,&extbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	memset(&pvalue->m,0,sizeof(pvalue->m));
	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.nonStandardDataPresent = optbit;

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.aliasAddressPresent = 1;

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.callSignalAddressPresent = 1;

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.rasAddressPresent = 1;

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.endpointTypePresent = 1;

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.tokensPresent = 1;

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.cryptoTokensPresent = 1;

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.priorityPresent = 1;
	
	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.remoteExtensionAddressPresent = 1;

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.destExtraCallInfoPresent = 1;

	if(pvalue->m.nonStandardDataPresent)
	{
		stat = asn1PD_H225NonStandardParameter(pctxt,&pvalue->nonStandardData);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(pvalue->m.aliasAddressPresent)
	{
		stat = asn1PD_H225_SeqOfH225AliasAddress(pctxt,&pvalue->aliasAddress);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(pvalue->m.callSignalAddressPresent)
	{
		stat = asn1PD_H225_SeqOfH225TransportAddress(pctxt,&pvalue->callSignalAddress);
	}

	if(pvalue->m.rasAddressPresent)
	{
		stat = asn1PD_H225_SeqOfH225TransportAddress(pctxt,&pvalue->rasAddress);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(pvalue->m.endpointTypePresent)
	{
		stat = asn1PD_H225EndpointType(pctxt,&pvalue->endpointType);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(pvalue->m.tokensPresent)
	{
		stat = asn1PD_H225_SeqOfH225ClearToken(pctxt,&pvalue->tokens);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(pvalue->m.cryptoTokensPresent)
	{
		stat = asn1PD_H225_SeqOfH225CryptoH323Token(pctxt,&pvalue->cryptoTokens);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(pvalue->m.priorityPresent)
	{
		stat = decodeConsUInt8(pctxt,&pvalue->priority,1U,127U);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(pvalue->m.remoteExtensionAddressPresent)
	{
		stat = asn1PD_H225_SeqOfH225AliasAddress(pctxt,&pvalue->remoteExtensionAddress);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(pvalue->m.destExtraCallInfoPresent)
	{
		stat = asn1PD_H225_SeqOfH225AliasAddress(pctxt,&pvalue->destExtraCallInfo);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(extbit)
	{
		stat = decodeSmallNonNegWholeNumber(pctxt,&bitcnt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
		bitcnt += 1;
		
		ZEROCONTEXT(&lctxt);
		stat = setPERBufferUsingCtxt(&lctxt,pctxt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

		stat = moveBitCursor (pctxt, bitcnt);
		if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

		for(i = 0; i < bitcnt; i++)
		{
			DECODEBIT(&lctxt,&optbit);
			if(optbit)
			{
				stat = decodeOpenType(pctxt,&openType.data,&openType.numocts);
				if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
				
				if(i < 3 && openType.numocts > 0)	//known element
				{
					copyContext(&lctxt2,pctxt);
					initContextBuffer(pctxt,openType.data,openType.numocts);
					switch(i)
					{
					case 0:
						pvalue->m.alternateTransportAddressesPresent = 1;
						stat = asn1PD_H225AlternateTransportAddresses(pctxt,&pvalue->alternateTransportAddresses);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 1:
						pvalue->m.circuitInfoPresent = 1;
						stat = asn1PD_H225CircuitInfo(pctxt,&pvalue->circuitInfo);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 2:
						pvalue->m.featureSetPresent = 1;
						stat = asn1PD_H225FeatureSet(pctxt,&pvalue->featureSet);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					default:
						pctxt->buffer.byteIndex += openType.numocts;
					}
					copyContext(pctxt,&lctxt2);
				}
				else	//unkown element
					pctxt->buffer.byteIndex += openType.numocts;
			}
		}
	}

	return stat;
}

EXTERN int asn1PD_H225_SeqOfH225Endpoint(OOCTXT* pctxt,H225_SeqOfH225Endpoint* pvalue)
{
	int stat = ASN_OK;
	H225Endpoint* pdata;
	ASN1UINT count = 0;
	ASN1UINT i;
	int lstat;

	dListInit (pvalue);

	for (;;)
	{
	  /* decode length determinant */
	  lstat = decodeLength (pctxt, &count);
	  if (lstat != ASN_OK && lstat != ASN_OK_FRAG)
		 return LOG_ASN1ERR (pctxt, lstat);

	  /* decode elements */
	  for (i = 0; i < count; i++)
	  {
		 pdata = ALLOC_ASN1ELEMDNODE (pctxt, H225Endpoint);
		 if (pdata == NULL)
			return LOG_ASN1ERR (pctxt, ASN_E_NOMEM);

		 stat = asn1PD_H225Endpoint(pctxt, pdata);
		 if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
		 dListAppendNode (pctxt, pvalue, pdata);
	  }

	  if(lstat == ASN_OK) break;
	}

	return stat;	
}

EXTERN int asn1PD_H225TransportQOS(OOCTXT *pctxt,H225TransportQOS *pvalue)
{
	int stat = ASN_OK;
	ASN1UINT ui;
	ASN1OpenType openType;
	ASN1BOOL extbit;

	stat = DECODEBIT(pctxt,&extbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	if(!extbit)
	{
		stat = decodeConsUnsigned(pctxt,&ui,0,2);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
		else pvalue->t = ui + 1;
		switch(pvalue->t)
		{
		case T_H225TransportQOS_endpointControlled:
			//NULL
			break;
		case T_H225TransportQOS_gatekeeperControlled:
			//NULL
			break;
		case T_H225TransportQOS_noControl:
			//NULL
			break;
		default:
			return LOG_ASN1ERR(pctxt,ASN_E_INVOPT);
		}
	}
	else
	{
		stat = decodeSmallNonNegWholeNumber(pctxt,&ui);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
		else pvalue->t = ui + 4;

		stat = decodeByteAlign(pctxt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

		stat = decodeOpenType(pctxt,&openType.data,&openType.numocts);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	return stat;
}

EXTERN int asn1PD_H225UUIEsRequested(OOCTXT *pctxt,H225UUIEsRequested *pvalue)
{
	int stat = ASN_OK;
	OOCTXT lctxt,lctxt2;
	ASN1OpenType openType;
	ASN1UINT i,bitcnt;
	ASN1BOOL optbit;
	ASN1BOOL extbit;
	
	stat = DECODEBIT(pctxt,&extbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	memset(&pvalue->m,0,sizeof(pvalue->m));
	stat = DECODEBIT(pctxt,&pvalue->setup);
	if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

	stat = DECODEBIT(pctxt,&pvalue->callProceeding);
	if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

	stat = DECODEBIT(pctxt,&pvalue->connect);
	if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

	stat = DECODEBIT(pctxt,&pvalue->alerting);
	if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

	stat = DECODEBIT(pctxt,&pvalue->information);
	if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

	stat = DECODEBIT(pctxt,&pvalue->releaseComplete);
	if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

	stat = DECODEBIT(pctxt,&pvalue->facility);
	if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
	

	stat = DECODEBIT(pctxt,&pvalue->progress);
	if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

	stat = DECODEBIT(pctxt,&pvalue->empty);
	if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

	if(extbit)
	{
		stat = decodeSmallNonNegWholeNumber(pctxt,&bitcnt);
		if(stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
		bitcnt += 1;

		ZEROCONTEXT(&lctxt);
		stat = setPERBufferUsingCtxt(&lctxt,pctxt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

		stat = moveBitCursor (pctxt, bitcnt);
		if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

		for(i = 0; i < bitcnt; i++)
		{
			DECODEBIT(&lctxt,&optbit);
			if(optbit)
			{
				stat = decodeOpenType(pctxt,&openType.data,&openType.numocts);
				if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
				if(i < 4 && openType.numocts > 0)	//known element
				{
					copyContext(&lctxt2,pctxt);
					initContextBuffer(pctxt,openType.data,openType.numocts);
					switch(i)
					{
					case 0:
						pvalue->m.statusPresent = 1;
						stat = DECODEBIT(pctxt,&pvalue->status);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 1:
						pvalue->m.statusInquiryPresent = 1;
						stat = DECODEBIT(pctxt,&pvalue->statusInquiry);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 2:
						pvalue->m.setupAcknowledgePresent = 1;
						stat = DECODEBIT(pctxt,&pvalue->setupAcknowledge);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 3:
						pvalue->m.notifyPresent = 1;
						stat = DECODEBIT(pctxt,&pvalue->notify);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					default:
						pctxt->buffer.byteIndex += openType.numocts;
					}
					copyContext(pctxt,&lctxt2);
				}
				else	//unknown element
					pctxt->buffer.byteIndex += openType.numocts;
			}
		}
	}

	return stat;
}

EXTERN int asn1PD_H225AdmissionConfirm_language(OOCTXT *pctxt,H225AdmissionConfirm_language *pvalue)
{
	static Asn1SizeCnst element_lsize1 = { 0, 1, 32, 0 };
	int stat = ASN_OK;
	ASN1UINT i;

	/* decode length determinant */

	stat = decodeLength (pctxt, &pvalue->n);
	if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

	/* decode elements */

	ALLOC_ASN1ARRAY (pctxt, pvalue, ASN1IA5String);

	for (i = 0; i < pvalue->n; i++) {
	  stat = addSizeConstraint (pctxt, &element_lsize1);
	  if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

	  stat = decodeConstrainedStringEx (pctxt, &pvalue->elem[i], 0, 8, 7, 7);
	  if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
	}

	return stat;	
}

EXTERN int asn1PD_H225AdmissionConfirm(OOCTXT *pctxt,H225AdmissionConfirm *pvalue)
{
	int stat = ASN_OK;
	OOCTXT lctxt,lctxt2;
	ASN1OpenType openType;
	ASN1UINT i,bitcnt;
	ASN1BOOL optbit;
	ASN1BOOL extbit;
	
	stat = DECODEBIT(pctxt,&extbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	
	memset(&pvalue->m,0,sizeof(pvalue->m));
	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.irrFrequencyPresent = optbit;

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.nonStandardDataPresent = optbit;

	stat = decodeConsUInt16(pctxt,&pvalue->requestSeqNum,1U,65535U);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	stat = asn1PD_H225BandWidth(pctxt,&pvalue->bandWidth);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	stat = asn1PD_H225CallModel(pctxt,&pvalue->callModel);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	stat = asn1PD_H225TransportAddress(pctxt,&pvalue->destCallSignalAddress);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	if(pvalue->m.irrFrequencyPresent)
	{
		stat = decodeConsUInt16(pctxt,&pvalue->irrFrequency,1U,65535U);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(pvalue->m.nonStandardDataPresent)
	{
		stat = asn1PD_H225NonStandardParameter(pctxt,&pvalue->nonStandardData);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(extbit)
	{
		stat = decodeSmallNonNegWholeNumber(pctxt,&bitcnt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
		bitcnt += 1;

		ZEROCONTEXT(&lctxt);
		stat = setPERBufferUsingCtxt(&lctxt,pctxt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

		stat = moveBitCursor (pctxt, bitcnt);
		if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

		for(i = 0; i < bitcnt; i++)
		{
			DECODEBIT(&lctxt,&optbit);
			if(optbit)
			{
				stat = decodeOpenType(pctxt,&openType.data,&openType.numocts);
				if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
				
				if(i < 22 && openType.numocts > 0) //known element
				{
					copyContext(&lctxt2,pctxt);
					initContextBuffer(pctxt,openType.data,openType.numocts);
					switch(i)
					{
					case 0:
						pvalue->m.destinationInfoPresent = 1;
						stat = asn1PD_H225_SeqOfH225AliasAddress(pctxt,&pvalue->destinationInfo);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 1:
						pvalue->m.destExtraCallInfoPresent = 1;
						stat = asn1PD_H225_SeqOfH225AliasAddress(pctxt,&pvalue->destExtraCallInfo);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 2:
						pvalue->m.destinationTypePresent = 1;
						stat = asn1PD_H225EndpointType(pctxt,&pvalue->destinationType);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 3:
						pvalue->m.remoteExtensionAddressPresent = 1;
						stat = asn1PD_H225_SeqOfH225AliasAddress(pctxt,&pvalue->remoteExtensionAddress);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 4:
						pvalue->m.alternateEndpointsPresent = 1;
						stat = asn1PD_H225_SeqOfH225Endpoint(pctxt,&pvalue->alternateEndpoints);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 5:
						pvalue->m.tokensPresent = 1;
						stat = asn1PD_H225_SeqOfH225ClearToken(pctxt,&pvalue->tokens);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 6:
						pvalue->m.cryptoTokensPresent = 1;
						stat = asn1PD_H225_SeqOfH225CryptoH323Token(pctxt,&pvalue->cryptoTokens);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 7:
						pvalue->m.integrityCheckValuePresent = 1;
						stat = asn1PD_H225ICV(pctxt,&pvalue->integrityCheckValue);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 8:
						pvalue->m.transportQOSPresent = 1;
						stat = asn1PD_H225TransportQOS(pctxt,&pvalue->transportQOS);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 9:
						pvalue->m.willRespondToIRRPresent = 1;
						stat = DECODEBIT(pctxt,&pvalue->willRespondToIRR);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 10:
						pvalue->m.uuiesRequestedPresent = 1;
						stat = asn1PD_H225UUIEsRequested(pctxt,&pvalue->uuiesRequested);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 11:
						pvalue->m.languagePresent = 1;
						stat = asn1PD_H225AdmissionConfirm_language(pctxt,&pvalue->language);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 12:
						pvalue->m.alternateTransportAddressesPresent = 1;
						stat = asn1PD_H225AlternateTransportAddresses(pctxt,&pvalue->alternateTransportAddresses);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 13:
						pvalue->m.useSpecifiedTransportPresent = 1;
						stat = asn1PD_H225UseSpecifiedTransport(pctxt,&pvalue->useSpecifiedTransport);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 14:
						pvalue->m.circuitInfoPresent = 1;
						stat = asn1PD_H225CircuitInfo(pctxt,&pvalue->circuitInfo);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 15:
						pvalue->m.usageSpecPresent = 1;
						stat = asn1PD_H225_SeqOfH225RasUsageSpecification(pctxt,&pvalue->usageSpec);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 16:
						pvalue->m.supportedProtocolsPresent = 1;
						stat = asn1PD_H225_SeqOfH225SupportedProtocols(pctxt,&pvalue->supportedProtocols);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 17:
						pvalue->m.serviceControlPresent = 1;
						stat = asn1PD_H225_SeqOfH225ServiceControlSession(pctxt,&pvalue->serviceControl);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 18:
						pvalue->m.multipleCallsPresent = 1;
						stat = DECODEBIT(pctxt,&pvalue->multipleCalls);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 19:
						pvalue->m.featureSetPresent = 1;
						stat = asn1PD_H225FeatureSet(pctxt,&pvalue->featureSet);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 20:
						pvalue->m.genericDataPresent = 1;
						stat = asn1PD_H225_SeqOfH225GenericData(pctxt,&pvalue->genericData);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					case 21:
						pvalue->m.modifiedSrcInfoPresent = 1;
						stat = asn1PD_H225_SeqOfH225AliasAddress(pctxt,&pvalue->modifiedSrcInfo);
						if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
						break;
					default:
						pctxt->buffer.byteIndex += openType.numocts;
					}
					copyContext(pctxt,&lctxt2);
				}
				else //unkown element
					pctxt->buffer.byteIndex += openType.numocts;
			}
		}
	}
	
	return stat;
}

EXTERN int asn1PD_H225AdmissionReject(OOCTXT *pctxt,H225AdmissionReject *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225BandwidthRequest(OOCTXT *pctxt,H225BandwidthRequest *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225BandwidthConfirm(OOCTXT *pctxt,H225BandwidthConfirm *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225BandwidthReject(OOCTXT *pctxt,H225BandwidthReject *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225disengageRequest(OOCTXT *pctxt,H225DisengageRequest *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225disengageConfirm(OOCTXT *pctxt,H225DisengageConfirm *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225disengageReject(OOCTXT *pctxt,H225DisengageReject *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225locationRequest(OOCTXT *pctxt,H225LocationRequest *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225locationConfirm(OOCTXT *pctxt,H225LocationConfirm *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225locationReject(OOCTXT*pctxt,H225LocationReject *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225infoRequest(OOCTXT *pctxt,H225InfoRequest *pvalue)
{
	int stat = ASN_OK;
	
	return stat;	
}

EXTERN int asn1PD_H225infoRequestResponse(OOCTXT*pctxt,H225InfoRequestResponse *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225NonStandardMessage(OOCTXT*pctxt,H225NonStandardMessage *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225UnknownMessageResponse(OOCTXT*pctxt,H225UnknownMessageResponse *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

//////////////////////////////////////////////////////////////////////////Ras message extension
EXTERN int asn1PD_H225RequestInProgress(OOCTXT *pctxt,H225RequestInProgress *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225ResourcesAvailableIndicate(OOCTXT *pctxt,H225ResourcesAvailableIndicate *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225ResourcesAvailableConfirm(OOCTXT*pctxt,H225ResourcesAvailableConfirm* pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225InfoRequestAck(OOCTXT *pctxt,H225InfoRequestAck *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN asn1PD_H225InfoRequestNak(OOCTXT *pctxt,H225InfoRequestNak *pvalue)
{
	int stat = ASN_OK;
	
	return stat;
}

EXTERN int asn1PD_H225ServiceControlIndication(OOCTXT *pctxt,H225ServiceControlIndication *pvalue)
{
	int stat = ASN_OK;
	ASN1BOOL extbit,optbit;
	ASN1UINT bitcnt,i;
	OOCTXT lctxt;
	ASN1OpenType openType;

	stat = DECODEBIT(pctxt,&extbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.nonStandardDataPresent = optbit;

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.endpointIdentifierPresent = optbit;

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.callSpecificPresent = optbit;

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.tokensPresent = optbit;

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.cryptoTokensPresent = optbit;

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.integrityCheckValuePresent = optbit;

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.featureSetPresent = optbit;

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.genericDataPresent = optbit;

	stat = decodeConsUInt16(pctxt,&pvalue->requestSeqNum,1U,65535U);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	
	if(pvalue->m.nonStandardDataPresent)
	{
		stat = asn1PD_H225NonStandardParameter(pctxt,&pvalue->nonStandardData);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	stat = asn1PD_H225_SeqOfH225ServiceControlSession(pctxt,&pvalue->serviceControl);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	if(pvalue->m.endpointIdentifierPresent)
	{
		stat = asn1PD_H225EndpointIdentifier(pctxt,&pvalue->endpointIdentifier);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}
	
	if(pvalue->m.tokensPresent)
	{
		stat = asn1PD_H225_SeqOfH225ClearToken(pctxt,&pvalue->tokens);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(pvalue->m.cryptoTokensPresent)
	{
		stat = asn1PD_H225_SeqOfH225CryptoH323Token(pctxt,&pvalue->cryptoTokens);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(pvalue->m.integrityCheckValuePresent)
	{
		stat = asn1PD_H225ICV(pctxt,&pvalue->integrityCheckValue);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(pvalue->m.featureSetPresent)
	{
		stat = asn1PD_H225FeatureSet(pctxt,&pvalue->featureSet);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(pvalue->m.genericDataPresent)
	{
		stat = asn1PD_H225_SeqOfH225GenericData(pctxt,&pvalue->genericData);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(extbit)
	{
		stat = decodeSmallNonNegWholeNumber(pctxt,&bitcnt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
		bitcnt += 1;
		
		ZEROCONTEXT(&lctxt);
		stat = setPERBufferUsingCtxt(&lctxt,pctxt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

		stat = moveBitCursor(pctxt,bitcnt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

		for(i = 0; i < bitcnt; i++)
		{
			DECODEBIT(&lctxt,&optbit);
			if(optbit)
			{
				stat = decodeOpenType(pctxt,&openType.data,&openType.numocts);
				if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

				pctxt->buffer.byteIndex += openType.numocts;
			}
		}
	}

	return stat;
}

EXTERN int asn1PD_H225ServiceControlResponse_result(OOCTXT *pctxt,H225ServiceControlResponse_result*pvalue)
{
	int stat = ASN_OK;
	ASN1UINT ui;
	ASN1OpenType openType;
	ASN1BOOL extbit;

	stat = DECODEBIT(pctxt,&extbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	if(!extbit)
	{
		stat = decodeConsUnsigned(pctxt,&ui,0,4);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
		else pvalue->t = ui + 1;

		switch(ui)
		{
		case T_H225ServiceControlResponse_result_started:
			//NULL
			break;
		case T_H225ServiceControlResponse_result_failed:
			//NULL
			break;
		case T_H225ServiceControlResponse_result_stopped:
			//NULL
			break;
		case T_H225ServiceControlResponse_result_notAvailable:
			//NULL
			break;
		case T_H225ServiceControlResponse_result_neededFeatureNotSupported:
			//NULL
			break;
		default:
			return LOG_ASN1ERR(pctxt,ASN_E_INVOPT);
		}
	}
	else
	{
		stat = decodeSmallNonNegWholeNumber(pctxt,&ui);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
		else pvalue->t = ui + 6;

		stat = decodeByteAlign(pctxt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

		stat = decodeOpenType(pctxt,&openType.data,&openType.numocts);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	return stat;
}

EXTERN int asn1PD_H225ServiceControlResponse(OOCTXT*pctxt,H225ServiceControlResponse *pvalue)
{
	int stat = ASN_OK;
	OOCTXT lctxt;
	ASN1OpenType openType;
	ASN1UINT bitcnt,i;
	ASN1BOOL extbit,optbit;
	
	stat = DECODEBIT(pctxt,&extbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	memset(&pvalue->m,0,sizeof(pvalue->m));

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.resultPresent = 1;

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.nonStandardDataPresent = 1;

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.tokensPresent = 1;

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.cryptoTokensPresent = 1;	

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.integrityCheckValuePresent = 1;

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.featureSetPresent = 1;		

	stat = DECODEBIT(pctxt,&optbit);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	else pvalue->m.genericDataPresent = 1;

	stat = decodeConsUInt16(pctxt,&pvalue->requestSeqNum,1U,65535U);
	if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

	if(pvalue->m.resultPresent)
	{
		stat = asn1PD_H225ServiceControlResponse_result(pctxt,&pvalue->result);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(pvalue->m.nonStandardDataPresent)
	{
		stat = asn1PD_H225NonStandardParameter(pctxt,&pvalue->nonStandardData);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}
	
	if(pvalue->m.tokensPresent)
	{
		stat = asn1PD_H225_SeqOfH225ClearToken(pctxt,&pvalue->tokens);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(pvalue->m.cryptoTokensPresent)
	{
		stat = asn1PD_H225_SeqOfH225CryptoH323Token(pctxt,&pvalue->cryptoTokens);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(pvalue->m.integrityCheckValuePresent)
	{
		stat = asn1PD_H225ICV(pctxt,&pvalue->integrityCheckValue);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(pvalue->m.featureSetPresent)
	{
		stat = asn1PD_H225FeatureSet(pctxt,&pvalue->featureSet);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}

	if(pvalue->m.genericDataPresent)
	{
		stat = asn1PD_H225_SeqOfH225GenericData(pctxt,&pvalue->genericData);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
	}
	
	//decode extension element
	if(extbit)
	{
		stat = decodeSmallNonNegWholeNumber (pctxt, &bitcnt);
		if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

		bitcnt += 1;

		ZEROCONTEXT (&lctxt);
		stat = setPERBufferUsingCtxt (&lctxt, pctxt);
		if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

		stat = moveBitCursor (pctxt, bitcnt);
		if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

		for (i = 0; i < bitcnt; i++)
		{
			DECODEBIT (&lctxt, &optbit);

			if (optbit)
			{
				stat = decodeOpenType (pctxt, &openType.data, &openType.numocts);
				if (stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);

				pctxt->buffer.byteIndex += openType.numocts;
			}
		}		
	}

	return stat;
}

EXTERN int asn1PD_H225RasMessage(OOCTXT* pctxt,H225RasMessage *pvalue)
{
	int stat = ASN_OK;
	OOCTXT lctxt;
	ASN1OpenType openType;
	ASN1BOOL extbit;
	ASN1UINT ui;
	
	stat = DECODEBIT(pctxt,&extbit);
	if(stat != ASN_OK) return LOG_ASN1ERR (pctxt, stat);
	if(!extbit)
	{
		stat = decodeConsUnsigned(pctxt,&ui,0,24);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
		else pvalue->t = ui + 1;

		switch(pvalue->t)
		{
		case T_H225RasMessage_gatekeeperRequest:
			pvalue->u.gatekeeperRequest = ALLOC_ASN1ELEM(pctxt,H225GatekeeperRequest);
			if(pvalue->u.gatekeeperRequest)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225GatekeeperRequest(pctxt,pvalue->u.gatekeeperRequest);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_gatekeeperConfirm:
			pvalue->u.gatekeeperConfirm = ALLOC_ASN1ELEM(pctxt,H225GatekeeperConfirm);
			if(pvalue->u.gatekeeperConfirm)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225GatekeeperConfirm(pctxt,pvalue->u.gatekeeperConfirm);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_gatekeeperReject:
			pvalue->u.gatekeeperReject = ALLOC_ASN1ELEM(pctxt,H225GatekeeperReject);
			if(pvalue->u.gatekeeperReject)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225GatekeeperReject(pctxt,pvalue->u.gatekeeperReject);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_registrationRequest:
			pvalue->u.registrationRequest = ALLOC_ASN1ELEM(pctxt,H225RegistrationRequest);
			if(pvalue->u.registrationRequest)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225RegistrationRequest(pctxt,pvalue->u.registrationRequest);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_registrationConfirm:
			pvalue->u.registrationConfirm = ALLOC_ASN1ELEM(pctxt,H225RegistrationConfirm);
			if(pvalue->u.registrationConfirm == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225RegistrationConfirm(pctxt,pvalue->u.registrationConfirm);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_registrationReject:
			pvalue->u.registrationReject = ALLOC_ASN1ELEM(pctxt,H225RegistrationReject);
			if(pvalue->u.registrationReject == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225RegistrationReject(pctxt,pvalue->u.registrationReject);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_unregistrationRequest:
			pvalue->u.unregistrationRequest = ALLOC_ASN1ELEM(pctxt,H225UnregistrationRequest);
			if(pvalue->u.unregistrationRequest == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225UnregistrationRequest(pctxt,pvalue->u.unregistrationRequest);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_unregistrationConfirm:
			pvalue->u.unregistrationConfirm = ALLOC_ASN1ELEM(pctxt,H225UnregistrationConfirm);
			if(pvalue->u.unregistrationConfirm == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225UnregistrationConfirm(pctxt,pvalue->u.unregistrationConfirm);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_unregistrationReject:
			pvalue->u.unregistrationReject = ALLOC_ASN1ELEM(pctxt,H225UnregistrationReject);
			if(pvalue->u.unregistrationReject == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225UnregistrationReject(pctxt,pvalue->u.unregistrationReject);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_admissionRequest:
			pvalue->u.admissionRequest = ALLOC_ASN1ELEM(pctxt,H225AdmissionRequest);
			if(pvalue->u.admissionRequest == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225AdmissionRequest(pctxt,pvalue->u.admissionRequest);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_admissionConfirm:
			pvalue->u.admissionConfirm = ALLOC_ASN1ELEM(pctxt,H225AdmissionConfirm);
			if(pvalue->u.admissionConfirm == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225AdmissionConfirm(pctxt,pvalue->u.admissionConfirm);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_admissionReject:
			pvalue->u.admissionReject = ALLOC_ASN1ELEM(pctxt,H225AdmissionReject);
			if(pvalue->u.admissionReject == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225AdmissionReject(pctxt,pvalue->u.admissionReject);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_bandwidthRequest:
			pvalue->u.bandwidthRequest = ALLOC_ASN1ELEM(pctxt,H225BandwidthRequest);
			if(pvalue->u.bandwidthRequest == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225BandwidthRequest(pctxt,pvalue->u.bandwidthRequest);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_bandwidthConfirm:
			pvalue->u.bandwidthConfirm = ALLOC_ASN1ELEM(pctxt,H225BandwidthConfirm);
			if(pvalue->u.bandwidthConfirm == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225BandwidthConfirm(pctxt,pvalue->u.bandwidthConfirm);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_bandwidthReject:
			pvalue->u.bandwidthReject = ALLOC_ASN1ELEM(pctxt,H225BandwidthReject);
			if(pvalue->u.bandwidthReject == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225BandwidthReject(pctxt,pvalue->u.bandwidthReject);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_disengageRequest:
			pvalue->u.disengageRequest = ALLOC_ASN1ELEM(pctxt,H225DisengageRequest);
			if(pvalue->u.disengageRequest == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225disengageRequest(pctxt,pvalue->u.disengageRequest);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_disengageConfirm:
			pvalue->u.disengageConfirm = ALLOC_ASN1ELEM(pctxt,H225DisengageConfirm);
			if(pvalue->u.disengageConfirm == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225disengageConfirm(pctxt,pvalue->u.disengageConfirm);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_disengageReject:
			pvalue->u.disengageReject = ALLOC_ASN1ELEM(pctxt,H225DisengageReject);
			if(pvalue->u.disengageReject == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225disengageReject(pctxt,pvalue->u.disengageReject);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_locationRequest:
			pvalue->u.locationRequest = ALLOC_ASN1ELEM(pctxt,H225LocationRequest);
			if(pvalue->u.locationRequest == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225locationRequest(pctxt,pvalue->u.locationRequest);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_locationConfirm:
			pvalue->u.locationConfirm = ALLOC_ASN1ELEM(pctxt,H225LocationConfirm);
			if(pvalue->u.locationConfirm == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225locationConfirm(pctxt,pvalue->u.locationConfirm);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_locationReject:
			pvalue->u.locationReject = ALLOC_ASN1ELEM(pctxt,H225LocationReject);
			if(pvalue->u.locationReject == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225locationReject(pctxt,pvalue->u.locationReject);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_infoRequest:
			pvalue->u.infoRequest = ALLOC_ASN1ELEM(pctxt,H225InfoRequest);
			if(pvalue->u.infoRequest == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225infoRequest(pctxt,pvalue->u.infoRequest);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);			
			break;
		case T_H225RasMessage_infoRequestResponse:
			pvalue->u.infoRequestResponse = ALLOC_ASN1ELEM(pctxt,H225InfoRequestResponse);
			if(pvalue->u.infoRequestResponse == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225infoRequestResponse(pctxt,pvalue->u.infoRequestResponse);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);			
			break;
		case T_H225RasMessage_nonStandardMessage:
			pvalue->u.nonStandardMessage = ALLOC_ASN1ELEM(pctxt,H225NonStandardMessage);
			if(pvalue->u.nonStandardMessage == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225NonStandardMessage(pctxt,pvalue->u.nonStandardMessage);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);	
			break;
		case T_H225RasMessage_unknownMessageResponse:
			pvalue->u.unknownMessageResponse = ALLOC_ASN1ELEM(pctxt,H225UnknownMessageResponse);
			if(pvalue->u.unknownMessageResponse == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225UnknownMessageResponse(pctxt,pvalue->u.unknownMessageResponse);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		default:
			return LOG_ASN1ERR(pctxt,ASN_E_INVOPT);
		}
	}
	else
	{
		stat = decodeSmallNonNegWholeNumber(pctxt,&ui);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
		else pvalue->t = ui + 26;
		
		stat = decodeByteAlign(pctxt);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);

		stat = decodeOpenType(pctxt,&openType.data,&openType.numocts);
		if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
		
		copyContext(&lctxt,pctxt);
		initContextBuffer(pctxt,openType.data,openType.numocts);
		
		switch(pvalue->t)
		{
		case T_H225RasMessage_requestInProgress:
			pvalue->u.requestInProgress = ALLOC_ASN1ELEM(pctxt,H225RequestInProgress);
			if(pvalue->u.requestInProgress == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225RequestInProgress(pctxt,pvalue->u.requestInProgress);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_resourcesAvailableIndicate:
			pvalue->u.resourcesAvailableIndicate = ALLOC_ASN1ELEM(pctxt,H225ResourcesAvailableIndicate);
			if(pvalue->u.resourcesAvailableIndicate == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = 	asn1PD_H225ResourcesAvailableIndicate(pctxt,pvalue->u.resourcesAvailableIndicate);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_resourcesAvailableConfirm:
			pvalue->u.resourcesAvailableConfirm = ALLOC_ASN1ELEM(pctxt,H225ResourcesAvailableConfirm);
			if(pvalue->u.resourcesAvailableConfirm == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225ResourcesAvailableConfirm(pctxt,pvalue->u.resourcesAvailableConfirm);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_infoRequestAck:
			pvalue->u.infoRequestAck = ALLOC_ASN1ELEM(pctxt,H225InfoRequestAck);
			if(pvalue->u.infoRequestAck == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225InfoRequestAck(pctxt,pvalue->u.infoRequestAck);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_infoRequestNak:
			pvalue->u.infoRequestNak = ALLOC_ASN1ELEM(pctxt,H225InfoRequestNak);
			if(pvalue->u.infoRequestNak == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225InfoRequestNak(pctxt,pvalue->u.infoRequestNak);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_serviceControlIndication:
			pvalue->u.serviceControlIndication = ALLOC_ASN1ELEM(pctxt,H225ServiceControlIndication);
			if(pvalue->u.serviceControlIndication == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225ServiceControlIndication(pctxt,pvalue->u.serviceControlIndication);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_serviceControlResponse:
			pvalue->u.serviceControlResponse = ALLOC_ASN1ELEM(pctxt,H225ServiceControlResponse);
			if(pvalue->u.serviceControlResponse == NULL)
				return LOG_ASN1ERR(pctxt,ASN_E_NOMEM);
			stat = asn1PD_H225ServiceControlResponse(pctxt,pvalue->u.serviceControlResponse);
			if(stat != ASN_OK) return LOG_ASN1ERR(pctxt,stat);
			break;
		case T_H225RasMessage_admissionConfirmSequence:
			break;
		}
		
		copyContext(pctxt,&lctxt);
	}

	return stat;
}
//added by tony above 12/08/2004